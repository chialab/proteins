{
  "version": 3,
  "sources": ["../../src/index.js", "../../src/types.js", "../../src/proto.js", "../../src/has.js", "../../src/_helpers.js", "../../src/clone.js", "../../src/merge.js", "../../src/equivalent.js", "../../src/symbolic.js", "../../src/mixin.js", "../../src/factory.js", "../../src/keypath.js", "../../src/events.js", "../../src/observable.js", "../../src/url.js"],
  "sourcesContent": ["/**\n * Proteins\n *\n * (c) 2017 Chialab (http://www.chialab.it) <dev@chialab.io>\n * http://chialab.io\n *\n * A primer for JavaScript libraries and frameworks development.\n */\n\nimport clone from './clone.js';\nimport merge from './merge.js';\nimport equivalent from './equivalent.js';\nimport mix, { MixinScope } from './mixin.js';\nimport Symbolic from './symbolic.js';\nimport Observable from './observable.js';\nimport has from './has.js';\nimport * as keypath from './keypath.js';\nimport * as Factory from './factory.js';\nimport * as Proto from './proto.js';\nimport * as Url from './url.js';\n\nexport * from './types.js';\nexport * from './events.js';\nexport { has };\nexport { Symbolic };\nexport { Observable };\nexport { clone };\nexport { merge };\nexport { equivalent };\nexport { mix };\nexport { MixinScope };\nexport { keypath };\nexport { Url };\nexport { Factory };\nexport { Proto };\n", "/**\n * Check if a value is a function.\n *\n * @param {*} obj The value to check.\n * @return {Boolean}\n */\nexport function isFunction(obj) {\n    return typeof obj === 'function';\n}\n/**\n * Check if a value is a string.\n *\n * @param {*} obj The value to check.\n * @return {Boolean}\n */\nexport function isString(obj) {\n    return typeof obj === 'string';\n}\n/**\n * Check if a value is a number.\n *\n * @param {*} obj The value to check.\n * @return {Boolean}\n */\nexport function isNumber(obj) {\n    return typeof obj === 'number' && !isNaN(obj);\n}\n/**\n * Check if a value is a bool.\n *\n * @param {*} obj The value to check.\n * @return {Boolean}\n */\nexport function isBoolean(obj) {\n    return typeof obj === 'boolean';\n}\n/**\n * Check if a value is a date.\n *\n * @param {*} obj The value to check.\n * @return {Boolean}\n */\nexport function isDate(obj) {\n    return obj instanceof Date;\n}\n/**\n * Check if a value is an object.\n *\n * @param {*} obj The value to check.\n * @return {Boolean}\n */\nexport function isObject(obj) {\n    return Object.prototype.toString.call(obj) === '[object Object]';\n}\n/**\n * Check if a value is undefined.\n *\n * @param {*} obj The value to check.\n * @return {Boolean}\n */\nexport function isUndefined(obj) {\n    return typeof obj === 'undefined';\n}\n/**\n * Check if a value is an array.\n *\n * @param {*} obj The value to check.\n * @return {Boolean}\n */\nexport function isArray(obj) {\n    return Array.isArray(obj) || obj instanceof Array;\n}\n/**\n * Check if falsy value.\n *\n * @param {*} obj The value to check.\n * @return {Boolean}\n */\nexport function isFalsy(obj) {\n    return isUndefined(obj) || obj === null || obj === false || (typeof obj === 'number' && isNaN(obj));\n}\n", "/**\n * @module Proto\n */\n\nimport { isFunction, isObject, isArray } from './types.js';\nimport hasOwnProperty from './has.js';\n\nconst getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nconst create = Object.create;\n\n/**\n * Iterate all prototype chain of a class.\n * @memberof Proto\n *\n * @param {Function} Ctr The class to iterate.\n * @param {Function} [callback] A callback function for each prototype.\n * @return {Array<string>}\n */\nexport function walk(Ctr, callback) {\n    let proto = Ctr.prototype;\n    while (proto) {\n        callback(proto);\n        proto = Object.getPrototypeOf(proto.constructor).prototype;\n    }\n}\n\n/**\n * Retrieve a list of properties and methods (with their descriptors) for the class.\n * @memberof Proto\n *\n * @param {Function} Ctr The class to analyze.\n * @param {Function} [filter] A filter function for the property.\n * @return {Object}\n */\nexport function entries(Ctr, filter = () => true) {\n    const res = {};\n    walk(Ctr, (proto) => {\n        Object.getOwnPropertyNames(proto)\n            .forEach((key) => {\n                if (!hasOwnProperty(res, key)) {\n                    const descriptor = getOwnPropertyDescriptor(proto, key);\n                    if (filter(key, descriptor)) {\n                        res[key] = descriptor;\n                    }\n                }\n            });\n    });\n    return res;\n}\n\n/**\n * Retrieve definitions of methods for the class.\n * @memberof Proto\n *\n * @param {Function} Ctr The class to analyze.\n * @return {Array<string>}\n */\nexport function methods(Ctr) {\n    return entries(Ctr, (key, descriptor) => isFunction(descriptor.value) && key !== 'constructor');\n}\n\n/**\n * Retrieve definitions of properties for the class.\n * @memberof Proto\n *\n * @param {Function} Ctr The class to analyze.\n */\nexport function properties(Ctr) {\n    return entries(Ctr, (key, descriptor) => !isFunction(descriptor.value));\n}\n\n/**\n * Get all definitions for a given property in the prototype chain.\n * @memberof Proto\n *\n * @param {Function} Ctr The class to analyze.\n * @param {string} property The property name to collect.\n * @return {Array<Object>}\n */\nexport function reduce(Ctr, property) {\n    const res = [];\n    walk(Ctr, (proto) => {\n        const descriptor = getOwnPropertyDescriptor(proto, property);\n        if (descriptor) {\n            res.push(descriptor);\n        }\n    });\n    return res;\n}\n\n/**\n * Check if a method or a property is in the prototype chain.\n * @memberof Proto\n *\n * @param {Function} Ctr The class to analyze.\n * @param {string} property The property name to verify.\n * @return {Boolean}\n */\nexport function has(Ctr, property) {\n    return !!reduce(Ctr, property).length;\n}\n\n/**\n * Retrieve prototype of an object.\n * @memberof Proto\n *\n * @param {Object} obj The object to analyze.\n * @return {Object} The prototype.\n */\nexport function get(obj) {\n    if (Object.getPrototypeOf) {\n        return Object.getPrototypeOf(obj);\n    }\n    if (isObject(obj.__proto__)) {\n        return obj.__proto__;\n    }\n    return obj.constructor.prototype;\n}\n\n/**\n * Set prototype to an object.\n * @memberof Proto\n *\n * @param {Object} obj The object to update.\n * @param {Object|Function} proto The prototype or the class to use.\n */\nexport function set(obj, proto) {\n    if (!isFunction(obj) && isFunction(proto)) {\n        proto = proto.prototype;\n    }\n    Object.setPrototypeOf ?\n        Object.setPrototypeOf(obj, proto) :\n        obj.__proto__ = proto;\n}\n\n/**\n * Extend a prototype.\n * @memberof Proto\n *\n * @param {Object} proto1 The prototype to extend.\n * @param {Object} proto2 The prototype to use.\n * @return {Object} The new prototype.\n */\nexport function extend(proto1, proto2) {\n    if (isFunction(proto1)) {\n        proto1 = proto1.prototype;\n    }\n    if (isFunction(proto2)) {\n        proto2 = proto2.prototype;\n    }\n    return create(proto1, proto2);\n}\n\n/**\n * Create a new instance of an object without constructor.\n * @memberof Proto\n *\n * @param {Function|Object} Ctr The class or the prototype to reconstruct.\n * @return {Object} The new instance.\n */\nexport function reconstruct(Ctr) {\n    if (isFunction(Ctr)) {\n        return reconstruct(Ctr.prototype);\n    } else if (isArray(Ctr)) {\n        const res = [];\n        set(res, Ctr);\n        return res;\n    }\n    return create(Ctr);\n}\n", "/**\n * Exec Object.prototype.hasOwnProperty against an object.\n * @param {Object} scope The scope object to check.\n * @param {string} property The property name to check.\n * @return {boolean}\n */\nexport default function has(scope, property) {\n    return Object.prototype.hasOwnProperty.call(scope, property);\n}\n", "/**\n * Get object's property descriptors.\n * This method is compatible with IE 11, Safari 9 and Chrome older than 54,\n * `Object.getOwnPropertyDescriptors` isn't.\n *\n * @param {Object} obj The Object.\n * @return {Object} Descriptors' map.\n */\nexport function getDescriptors(obj) {\n    return Object.getOwnPropertyNames(obj)\n        .reduce((acc, propName) => {\n            acc[propName] = Object.getOwnPropertyDescriptor(obj, propName);\n            return acc;\n        }, {});\n}\n\n/**\n * Build a new configurable descriptor starting from passed `descriptor`.\n * @param {Object} descriptor The descriptor to clone.\n * @param {*} val The value to set as `value` descriptor property.\n * @param {boolean} writable Writable configuration of the descriptor.\n * @return {Object} New descriptor.\n */\nexport function buildDescriptor(descriptor, val, writable = true) {\n    const newDescriptor = {\n        configurable: true,\n        enumerable: descriptor.enumerable,\n    };\n    if (descriptor.get || descriptor.set) {\n        newDescriptor.get = descriptor.get;\n        newDescriptor.set = descriptor.set;\n    } else {\n        // `value` and `writable` are allowed in a descriptor only when there isn't a getter/setter.\n        newDescriptor.value = val;\n        newDescriptor.writable = writable;\n    }\n    return newDescriptor;\n}\n", "import { isObject, isDate, isArray, isFunction } from './types.js';\nimport { get, reconstruct } from './proto.js';\nimport { getDescriptors, buildDescriptor } from './_helpers.js';\n\n/**\n * Useless callback function.\n * @private\n *\n * @param {*} scope The current object.\n * @param {string} key The current key.\n * @param {*} prop The current value.\n */\nfunction noop(scope, key, prop) { return prop; }\n\n/**\n * Clone an object.\n *\n * @method clone\n * @param {*} obj The instance to clone.\n * @param {Function} [callback] A modifier function for each property.\n * @param {boolean} [useStrict] Should preserve frozen and sealed objects.\n * @param {WeakMap} [cache] The cache for circular references.\n * @return {*} The clone of the object.\n */\nexport default function clone(obj, callback = noop, useStrict = false, cache = new WeakMap()) {\n    if (typeof callback === 'boolean') {\n        useStrict = callback;\n        callback = noop;\n    }\n    if (isObject(obj) || isArray(obj)) {\n        if (cache.has(obj)) {\n            return cache.get(obj);\n        }\n        const res = reconstruct(get(obj));\n        cache.set(obj, res);\n        const newDescriptors = getDescriptors(res);\n        const descriptors = getDescriptors(obj);\n        for (const key in descriptors) {\n            const descriptor = descriptors[key];\n            if (newDescriptors[key] && !newDescriptors[key].configurable) {\n                continue;\n            }\n            let value;\n            if ('value' in descriptor) {\n                value = callback(obj, key, clone(descriptor.value, callback, useStrict, cache));\n            }\n            Object.defineProperty(res, key, buildDescriptor(descriptor, value, useStrict ? descriptor.writable : true));\n        }\n        if (useStrict) {\n            if (Object.isFrozen(obj)) {\n                Object.freeze(res);\n            } else if (Object.isSealed(obj)) {\n                Object.seal(res);\n            }\n        }\n        return res;\n    } else if (isDate(obj)) {\n        return new Date(obj.getTime());\n    } else if (isFunction(obj)) {\n        return obj;\n    }\n    return obj;\n}\n", "import clone from './clone.js';\nimport { getDescriptors, buildDescriptor } from './_helpers.js';\nimport { isObject, isArray } from './types.js';\n\nconst defaults = {\n    mergeObjects: true,\n    joinArrays: false,\n    strictMerge: false,\n};\n\n/**\n * Merge two objects into a new one.\n *\n * @method merge\n * @param {...Object|Array} objects The objects to merge.\n * @return {Object} The merged object.\n */\nexport default function merge(...objects) {\n    let options = defaults;\n    if (typeof this !== 'undefined' && this.options) {\n        options = this.options;\n    }\n    const first = objects.shift();\n    const res = clone(first);\n\n    objects.forEach((obj2) => {\n        if (isObject(first) && isObject(obj2)) {\n            const descriptors = getDescriptors(obj2);\n            Object.keys(descriptors).forEach((key) => {\n                const leftDescriptor = Object.getOwnPropertyDescriptor(first, key);\n                const rightDescriptor = descriptors[key];\n                if (!('value' in rightDescriptor)) {\n                    Object.defineProperty(res, key, buildDescriptor(rightDescriptor));\n                    return;\n                }\n\n                if (options.strictMerge) {\n                    if (!leftDescriptor) {\n                        return;\n                    }\n                    if (typeof leftDescriptor.get !== typeof rightDescriptor.get) {\n                        return;\n                    }\n                    if (typeof leftDescriptor.set !== typeof rightDescriptor.set) {\n                        return;\n                    }\n                }\n\n                let rightVal = clone(rightDescriptor.value);\n                if (leftDescriptor && rightVal) {\n                    const leftVal = leftDescriptor.value;\n                    if (isObject(leftVal) && isObject(rightVal) && options.mergeObjects) {\n                        rightVal = merge.call(this, leftVal, rightVal);\n                    } else if (isArray(leftVal) && isArray(rightVal) && options.joinArrays) {\n                        rightVal = merge.call(this, leftVal, rightVal);\n                    }\n                }\n                Object.defineProperty(res, key, buildDescriptor(rightDescriptor, rightVal));\n            });\n        } else if (isArray(first) && isArray(obj2)) {\n            const descriptors = getDescriptors(obj2);\n            // Skip length descriptor.\n            delete descriptors.length;\n            Object.keys(descriptors).forEach((key) => {\n                const rightDescriptor = descriptors[key];\n                if (!('value' in rightDescriptor)) {\n                    Object.defineProperty(res, key, buildDescriptor(rightDescriptor));\n                    return;\n                }\n\n                const leftVal = first[key];\n                let rightVal = clone(rightDescriptor.value);\n                if (!isNaN(key)) {\n                    if (options.joinArrays) {\n                        // check if already in the left array\n                        if (first.indexOf(rightVal) === -1) {\n                            // append the value instead of overwriting\n                            res.push(rightVal);\n                        }\n                        return;\n                    }\n\n                    if (isObject(leftVal) && isObject(rightVal) && options.mergeObjects) {\n                        rightVal = merge.call(this, leftVal, rightVal);\n                    } else if (isArray(leftVal) && isArray(rightVal)) {\n                        rightVal = merge.call(this, leftVal, rightVal);\n                    }\n                }\n                Object.defineProperty(res, key, buildDescriptor(rightDescriptor, rightVal));\n            });\n        } else {\n            throw 'incompatible types';\n        }\n    });\n    return res;\n}\n\n/**\n * Create a new Merge function with passed options.\n *\n * @method config\n * @memberof merge\n * @param {Object} options Merge options.\n * @param {Boolean} options.mergeObjects Should ricursively merge objects keys.\n * @param {Boolean} options.joinArrays Should join arrays instead of update keys.\n * @param {Boolean} options.strictMerge Should merge only keys which already are in the first object.\n * @return {Function} The new merge function.\n */\nmerge.config = function(options = {}) {\n    return (...args) => merge.call({\n        options: merge(defaults, options),\n    }, ...args);\n};\n", "import { isObject, isDate, isArray, isFunction } from './types.js';\n\n/**\n * Internal objects equivalence check.\n * @private\n * @param {*} obj1 The original object.\n * @param {*} obj2 The object to compare\n * @param {Array} [processing] A list of already processed comparisons.\n * @return {Boolean}\n */\nfunction internalEquivalent(obj1, obj2, processing = []) {\n    if (typeof obj1 === typeof obj2) {\n        if (isArray(obj1)) {\n            if (obj1.length === obj2.length) {\n                // Arrays have the same length\n                for (let i = 0, len = obj1.length; i < len; i++) {\n                    if (!internalEquivalent(obj1[i], obj2[i], processing)) {\n                        // Deep check failed.\n                        return false;\n                    }\n                }\n                return true;\n            }\n            return false;\n        } else if (isObject(obj1)) {\n            // handle multiple object instance check.\n            let processSourceIndex = processing.indexOf(obj1);\n            while (processSourceIndex !== -1) {\n                // `processing` array contains pairs of compared object, so left objects have always even index\n                if (processSourceIndex % 2 === 0 && processing[processSourceIndex + 1] === obj2) {\n                    // The comparison between the two objects has been already handled before.\n                    return true;\n                }\n                // The same object could be compared more than once, so we have to check for all references.\n                processSourceIndex = processing.indexOf(obj1, processSourceIndex);\n            }\n            processing.push(obj1, obj2);\n            const sourceKeys = Object.keys(obj1).sort();\n            const targetKeys = Object.keys(obj2).sort();\n            if (internalEquivalent(sourceKeys, targetKeys)) {\n                // objects keys are equivalent.\n                for (let i = 0, len = sourceKeys.length; i < len; i++) {\n                    const key = sourceKeys[i];\n                    if (!internalEquivalent(obj1[key], obj2[key], processing)) {\n                        // deep check failed.\n                        return false;\n                    }\n                }\n                return true;\n            }\n            return false;\n        } else if (isDate(obj1) && isDate(obj2)) {\n            // We cannot compare two dates just using `===`, so we use their timestamps.\n            return obj1.getTime() === obj2.getTime();\n        } else if (isFunction(obj1.valueOf) && isFunction(obj2.valueOf)) {\n            // Use `valueOf` method if available.\n            return obj1.valueOf() === obj2.valueOf();\n        }\n        // Generic check.\n        return obj1 === obj2;\n    }\n    // Comparison failed because object types mismatch.\n    return false;\n}\n\n/**\n * Recursive objects equivalence check.\n * @param {*} obj1 The original object.\n * @param {*} obj2 The object to compare\n * @return {Boolean}\n */\nexport default function equivalent(obj1, obj2) {\n    return internalEquivalent(obj1, obj2);\n}\n", "const support = (typeof Symbol === 'function');\n\n/**\n * Polyfill registry for symbols.\n * @private\n * @type {Array}\n */\nconst registry = [];\n\n/**\n * Polyfill for Symbol.\n * @class SymbolPolyfill\n * @private\n *\n * @param {string} property The Symbol name.\n */\nclass SymbolPolyfill {\n    constructor(property) {\n        const sym = this.SYM = `__${property}_${registry.length}`;\n        registry.push(sym);\n        Object.defineProperty(Object.prototype, sym, {\n            configurable: true,\n            enumerable: false,\n            set(x) {\n                Object.defineProperty(this, sym, {\n                    configurable: true,\n                    enumerable: false,\n                    writable: true,\n                    value: x,\n                });\n            },\n        });\n    }\n\n    toString() {\n        return this.SYM;\n    }\n}\n\n/**\n * Create a symbolic key for objects's properties.\n *\n * @param {string} property The Symbol name.\n * @return {Symbol|Symbolic}\n */\nexport default function Symbolic(property) {\n    if (support) {\n        // native Symbol support.\n        const sym = Symbol(property);\n        registry.push(sym);\n        return sym;\n    }\n    return new SymbolPolyfill(property);\n}\n\n/**\n * Check if an instance is a Symbol.\n * @param {Symbol|Symbolic} sym The symbol to check.\n * @return {Boolean}\n */\nSymbolic.isSymbolic = function(sym) {\n    if (!sym) {\n        return false;\n    }\n    if (sym instanceof SymbolPolyfill) {\n        sym = sym.toString();\n    }\n    return registry.indexOf(sym) !== -1;\n};\n", "import Symbolic from './symbolic.js';\nimport hasOwnProperty from './has.js';\n\nconst MIXINS_SYM = Symbolic('mixins');\n\n/**\n * Mix a class with a mixin.\n * Inspired by Justin Fagnani (https://github.com/justinfagnani).\n *\n * @param {Function} SuperClass The class to extend.\n * @return {MixinScope} A MixinScope instance.\n */\nexport default function mix(SuperClass) {\n    return new MixinScope(SuperClass);\n}\n\n/**\n * A Mixin helper class.\n */\nexport class MixinScope {\n    /**\n     * Create a mixable class.\n     * @param {Function} superClass The class to extend.\n     */\n    constructor(superClass) {\n        this.superClass = superClass || class { };\n    }\n    /**\n     * Mix the super class with a list of mixins.\n     *\n     * @param {...Function} mixins *N* mixin functions.\n     * @return {*} The extended class.\n     */\n    with(...mixins) {\n        let Class = this.superClass;\n        mixins.forEach((mixin) => {\n            if (!this.has(mixin)) {\n                Class = mixin(Class);\n            }\n        });\n        Class[MIXINS_SYM] = hasOwnProperty(Class, MIXINS_SYM) ? Class[MIXINS_SYM] : [];\n        Class[MIXINS_SYM].push(...mixins);\n        return Class;\n    }\n    /**\n     * Check if the SuperClass has been already mixed with a mixin function.\n     *\n     * @param {Function} mixin The mixin function.\n     * @return {Boolean}\n     */\n    has(mixin) {\n        let Class = this.superClass;\n        while (Class && Class !== Object) {\n            const attached = Class[MIXINS_SYM] || [];\n            if (attached.indexOf(mixin) !== -1) {\n                return true;\n            }\n            Class = Object.getPrototypeOf(Class);\n        }\n        return false;\n    }\n}\n", "/**\n * A set of classes with super powers.\n * For direct or extended use.\n *\n * @module Factory\n */\n\nimport mix from './mixin.js';\nimport Symbolic from './symbolic.js';\nimport * as keypath from './keypath.js';\nimport clone from './clone.js';\nimport merge from './merge.js';\nimport hasOwnProperty from './has.js';\nimport { isObject, isString } from './types.js';\nimport { on, off, trigger } from './events.js';\nimport { has } from './proto.js';\n\n/**\n * Symbol for Factory instances.\n * @type {Symbolic}\n */\nconst FACTORY_SYM = Symbolic('fsymbol');\n\n/**\n * Symbol for Factory context.\n * @type {Symbolic}\n */\nexport const CONTEXT_SYM = Symbolic('context');\n\n/**\n * Symbol for Factory configuration.\n * @type {Symbolic}\n */\nexport const CONFIG_SYM = Symbolic('config');\n\n/**\n * Symbol for Factory listeners.\n * @type {Symbolic}\n */\nexport const LISTENERS_SYM = Symbolic('listeners');\n\nlet context;\n\nconst FACTORY_SYMBOLS = {};\n\n/**\n * Base Factory mixin.\n * @mixin FactoryMixin\n *\n * @param {Function} SuperClass The class to mix.\n * @return {Function} A base Factory constructor.\n */\nexport const FactoryMixin = (SuperClass) =>\n    class BaseFactory extends SuperClass {\n        /**\n         * A symbolic defintion for the Factory constructor.\n         * @type {Symbolic}\n         */\n        static get SYM() {\n            if (!hasOwnProperty(this, FACTORY_SYM)) {\n                const sym = Symbolic(this.name);\n                FACTORY_SYMBOLS[sym] = this;\n                this[FACTORY_SYM] = sym;\n            }\n            return this[FACTORY_SYM];\n        }\n\n        constructor(...args) {\n            super(...args);\n            this.initialize(...args);\n        }\n\n        /**\n         * @param {...*} [args] Arguments for super initialize.\n         */\n        initialize(...args) {\n            if (!this[CONTEXT_SYM]) {\n                this[CONTEXT_SYM] = context || this;\n            }\n            return has(SuperClass, 'initialize') && super.initialize(...args);\n        }\n\n        /**\n         * Init a new Factory with the same context.\n         *\n         * @param {Function} Factory The Factory constructor.\n         * @param {...*} args A list of arguments for the constructor.\n         * @return {Object} The new instance.\n         */\n        init(Factory, ...args) {\n            context = this[CONTEXT_SYM];\n            const res = new Factory(...args);\n            context = null;\n            return res;\n        }\n\n        /**\n         * Clear the context.\n         */\n        destroy() {\n            delete this[CONTEXT_SYM];\n            return has(SuperClass, 'destroy') && super.destroy();\n        }\n    };\n\n/**\n * Events emitter mixin.\n * @mixin EmitterMixin\n *\n * @param {Function} SuperClass The class to mix.\n * @return {Function} A Emitter constructor.\n */\nexport const EmitterMixin = (SuperClass) =>\n    class Emitter extends mix(SuperClass).with(FactoryMixin) {\n        /**\n         * @param {...*} [args] Arguments for the constructor.\n         */\n        initialize(...args) {\n            super.initialize(...args);\n            if (!this[LISTENERS_SYM]) {\n                this[LISTENERS_SYM] = [];\n            }\n        }\n\n        /**\n         * Add an event listener.\n         *\n         * @param {string} name The event name.\n         * @param {Function} callback The callback to exec for the event.\n         * @return {Function} A listener destroyer.\n         */\n        on(name, callback) {\n            return on(this, name, callback);\n        }\n\n        /**\n         * Remove an event(s) listener(s).\n         *\n         * @param {string} [name] The event name.\n         * @param {Function} [callback] The optional callback to remove.\n         */\n        off(name, callback) {\n            return off(this, name, callback);\n        }\n\n        /**\n         * Dispatch an event.\n         *\n         * @param {string} name The event name.\n         * @param {...*} args A list of arguments to pass to listeners.\n         * @return {Promise} It resolves when all listeners have been triggered.\n         */\n        trigger(name, ...args) {\n            return trigger(this, name, ...args);\n        }\n\n        /**\n         * Listen events from another object.\n         *\n         * @param {Object} obj The object to listen.\n         * @param {string} name The event name.\n         * @param {Function} callback The callback to exec for the event.\n         * @return {Function} A listener destroyer.\n         */\n        listen(obj, name, callback) {\n            const destroyer = on(obj, name, callback);\n            this[LISTENERS_SYM].push(destroyer);\n            return destroyer;\n        }\n\n        /**\n         * Unlisten event(s) from another object(s).\n         *\n         * @param {Object} [obj] The object to unlisten.\n         * @param {string} [name] The event name.\n         * @param {Function} [callback] The callback to exec for the event.\n         * @return {Function} A listener destroyer.\n         */\n        unlisten(obj, name, callback) {\n            if (obj) {\n                off(obj, name, callback);\n            } else {\n                this[LISTENERS_SYM].forEach((offListener) => offListener());\n                this[LISTENERS_SYM] = [];\n            }\n        }\n\n        /**\n         * Clear all listeners.\n         */\n        destroy() {\n            this.off();\n            this.unlisten();\n            return super.destroy();\n        }\n    };\n\n/**\n * Configurable mixin.\n * @mixin ConfigurableMixin\n *\n * @param {Function} SuperClass The class to mix.\n * @return {Function} A Configurable constructor.\n */\nexport const ConfigurableMixin = (SuperClass) =>\n    class Configurable extends mix(SuperClass).with(FactoryMixin) {\n        /**\n         * @param {Object} [config] The instance configuration object.\n         * @param {...*} [args] Other arguments for the super constructor.\n         */\n        initialize(config, ...args) {\n            super.initialize(config, ...args);\n            if (!this[CONFIG_SYM]) {\n                this[CONFIG_SYM] = clone(this.defaultConfig || {});\n                if (config) {\n                    this.config(config);\n                }\n            }\n        }\n\n        /**\n         * Default config object.\n         */\n        get defaultConfig() {\n            return {};\n        }\n\n        /**\n         * Update instance configuration.\n         *\n         * @param {Object|string} config The configuration to update (or the path of the configuration property).\n         * @param {*} [value] The value to update for the given config name.\n         * @return {Object} Final configuration of the instance.\n         */\n        config(config, ...args) {\n            let current = this[CONFIG_SYM];\n            if (args.length === 0 && isString(config)) {\n                return keypath.get(current, config);\n            }\n            const value = args[0];\n            if (isString(config)) {\n                const oldValue = keypath.get(current, config);\n                if (oldValue !== value) {\n                    keypath.set(current, config, value);\n                    this.trigger('config:changed', config, oldValue, value);\n                }\n            }\n            if (isObject(config)) {\n                current = merge(current, config);\n            }\n            this[CONFIG_SYM] = current;\n            return current;\n        }\n\n        /**\n         * Clear the configuration.\n         */\n        destroy() {\n            delete this[CONFIG_SYM];\n            return super.destroy();\n        }\n    };\n\n/**\n * Mixin for other multiple injections.\n * @mixin InjectableMixin\n *\n * @param {Function} SuperClass The class to mix.\n * @return {Function} A Factory constructor.\n */\nexport const InjectableMixin = (SuperClass) =>\n    class Factory extends mix(SuperClass).with(FactoryMixin) {\n        /**\n         * @param {...*} [args] Arguments for the constructor.\n         */\n        initialize(...args) {\n            super.initialize(...args);\n            const ctx = this[CONTEXT_SYM];\n            this.inject.forEach((Injector) => {\n                if (Symbolic.isSymbolic(Injector)) {\n                    Injector = FACTORY_SYMBOLS[Injector];\n                }\n                if (!this[Injector.SYM]) {\n                    if (ctx) {\n                        this[Injector.SYM] = ctx[Injector.SYM] = ctx[Injector.SYM] || this.init(Injector);\n                    } else {\n                        this[Injector.SYM] = this.init(Injector);\n                    }\n                }\n            });\n        }\n\n        /**\n         * A default list of injections.\n         */\n        get inject() {\n            return [];\n        }\n\n        /**\n         * Clear injected methods.\n         */\n        destroy() {\n            this.inject.forEach((Injector) => {\n                const SYM = (Symbolic.isSymbolic(Injector)) ? Injector : Injector.SYM;\n                delete this[SYM];\n            });\n            return super.destroy();\n        }\n    };\n\nexport class BaseFactory extends mix().with(FactoryMixin) { }\n\nexport class Emitter extends mix().with(EmitterMixin) { }\n\nexport class Configurable extends mix().with(ConfigurableMixin) { }\n\nexport class Factory extends mix().with(EmitterMixin, ConfigurableMixin, InjectableMixin) { }\n", "import hasOwnProperty from './has.js';\n\n/**\n * @module keypath\n */\n\nimport {\n    isNumber,\n    isString,\n    isBoolean,\n    isObject,\n    isArray,\n    isFalsy,\n} from './types.js';\n\n/**\n * Assert scope object is a valid object.\n * @private\n *\n * @param {*} obj The object to check\n * @return {boolean} The object is valid or not\n */\nfunction assertObject(obj) {\n    return !isFalsy(obj) && typeof obj === 'object';\n}\n\n/**\n * Assert scope object and path are valid\n * @private\n *\n * @param {*} obj The object to check\n * @param {*} path The property path\n * @return {void}\n * @throws {Error} throw error when object scope is invalid undefined\n * @throws {Error} throw error when paths is invalid or undefined\n */\nfunction assertArgs(obj, path) {\n    if (!assertObject(obj)) {\n        throw new Error('invalid scope');\n    }\n    if (isFalsy(path) || (isArray(path) && path.length === 0)) {\n        throw new Error('invalid path');\n    }\n}\n\n/**\n * Normalize path argument in an array of paths\n * @private\n *\n * @param {Array|string|number} path The argument to normalize\n * @return {Array} An array of paths\n */\nfunction pathToArray(path) {\n    if (isString(path)) {\n        return path.split('.');\n    }\n    if (isNumber(path)) {\n        return [`${path}`];\n    }\n    if (isArray(path)) {\n        return path.slice(0);\n    }\n    return path;\n}\n\n/**\n * Get a deep property of an object using paths\n * @function get\n * @memberof keypath\n *\n * @param {Object} obj The object scope\n * @param {String|Array} path The path of the property to retrieve\n * @param {*} defaultValue The default value returned if path was not found. Default is undefined.\n * @return {*} The property value\n * @throws {Error} throw error when object scope is undefined\n * @throws {Error} throw error when paths is invalid or undefined\n */\nexport function get(obj, path, defaultValue) {\n    assertArgs(obj, path);\n    if (!has(obj, path)) {\n        return defaultValue;\n    }\n    let value = obj;\n    path = pathToArray(path);\n    path.forEach(prop => {\n        value = value[prop];\n    });\n    return value;\n}\n\n/**\n * Set a deep property of an object using paths\n * @memberof keypath\n *\n * @param {Object} obj The object scope\n * @param {String|Array} path The path of the property to set\n * @param {*} value The value to set\n * @param {boolean} [ensure=true] Create path if does not exists\n * @return {*} The property value\n * @throws {Error} throw error when object scope is invalid undefined\n * @throws {Error} throw error when paths is invalid or undefined\n */\nexport function set(obj, path, value, ensure = true) {\n    assertArgs(obj, path);\n    path = pathToArray(path);\n    if (path.length === 1) {\n        if (isArray(obj) && path[0] === '') {\n            obj.push(value);\n        } else {\n            obj[path[0]] = value;\n        }\n        return value;\n    }\n    const current = path.shift();\n    let currentObj;\n    if (!hasOwnProperty(obj, current)) {\n        if (ensure) {\n            const next = path[0];\n            if (isNaN(next) && next !== '') {\n                currentObj = obj[current] = {};\n            } else {\n                currentObj = obj[current] = [];\n            }\n        }\n    } else {\n        currentObj = obj[current];\n    }\n    return set(currentObj, path, value, ensure);\n}\n\n/**\n * Check deep object property existence using paths\n * @memberof keypath\n *\n * @param {Object} obj The object scope\n * @param {String|Array} path The path of the property to retrieve\n * @return {boolean} The property exists or not\n * @throws {Error} throw error when object scope is invalid undefined\n * @throws {Error} throw error when paths is invalid or undefined\n */\nexport function has(obj, path) {\n    if (!assertObject(obj)) {\n        return false;\n    }\n    assertArgs(obj, path);\n    path = pathToArray(path);\n    let current = path.shift();\n    if (isArray(obj) && !isNaN(current)) {\n        current = parseInt(current);\n        if (obj.length > current) {\n            if (path.length === 0) {\n                return true;\n            }\n            return has(obj[current], path);\n        }\n    }\n    if (current in obj || hasOwnProperty(obj, current)) {\n        if (path.length === 0) {\n            return true;\n        }\n        return has(obj[current], path);\n    }\n    return false;\n}\n\n/**\n * Ensure the existance of a value for the given path.\n * If the value already exists, do nothing.\n * @function ensure\n * @memberof keypath\n *\n * @param {Object} obj The object scope\n * @param {String|Array} path The path of the property to retrieve\n * @param {*} value The default value to set\n * @return {*} The actual value for the given property\n * @throws {Error} throw error when object scope is invalid undefined\n * @throws {Error} throw error when paths is invalid or undefined\n */\nexport function ensure(obj, path, value) {\n    const val = get(obj, path);\n    if (!val) {\n        set(obj, path, value);\n    }\n    return val;\n}\n\n/**\n * Push or insert a value in array.\n * @memberof keypath\n *\n * @param {Object} obj The object scope\n * @param {String|Array} path The path of the property to retrieve\n * @param {*} value The value to push\n * @param {number} [index] The index to replace (empty, push at the end)\n * @return {Array} The modified array\n * @throws {Error} throw error when object scope is invalid undefined\n * @throws {Error} throw error when paths is invalid or undefined\n */\nexport function insert(obj, path, value, index) {\n    assertArgs(obj, path);\n    path = pathToArray(path);\n    let arr = [];\n    arr = ensure(obj, path, arr) || arr;\n    if (isArray(arr)) {\n        if (!isFalsy(index)) {\n            arr.splice(index, 0, value);\n        } else {\n            arr.push(value);\n        }\n    }\n    return arr;\n}\n\n/**\n * Reset the value at the given path.\n * * Object \u2192 remove all keys from the object\n * * Array \u2192 remove all values from the array\n * * String \u2192 reset to empty string\n * * Number \u2192 reset to 0\n * * any \u2192 reset to null\n * @memberof keypath\n *\n * @param {Object} obj The object scope\n * @param {String|Array} path The path of the property to retrieve\n * @return {*} The modified object\n * @throws {Error} throw error when object scope is invalid undefined\n * @throws {Error} throw error when paths is invalid or undefined\n */\nexport function empty(obj, path) {\n    assertArgs(obj, path);\n    path = pathToArray(path);\n    let parent = obj;\n    if (path.length > 1) {\n        parent = get(obj, path.slice(0, -1));\n    }\n    const current = path[path.length - 1];\n    if (parent && hasOwnProperty(parent, current)) {\n        const arr = parent[current];\n        if (isArray(arr)) {\n            arr.splice(0, arr.length);\n        } else if (isObject(arr)) {\n            for (const k in arr) {\n                delete arr[k];\n            }\n        } else if (isString(arr)) {\n            parent[current] = '';\n        } else if (isNumber(arr)) {\n            parent[current] = 0;\n        } else if (isBoolean(arr)) {\n            parent[current] = false;\n        } else {\n            parent[current] = null;\n        }\n        return arr;\n    }\n    return null;\n}\n\n/**\n * Remove a key from the parent path.\n * @memberof keypath\n *\n * @param {Object} obj The object scope\n * @param {String|Array} path The path of the property to retrieve\n * @return {*} The parent path object\n * @throws {Error} throw error when object scope is invalid undefined\n * @throws {Error} throw error when paths is invalid or undefined\n */\nexport function del(obj, path) {\n    assertArgs(obj, path);\n    path = pathToArray(path);\n    const pathToDelete = path.pop();\n    let subObj = obj;\n    if (path.length) {\n        subObj = get(obj, path);\n    }\n    if (isObject(subObj)) {\n        delete subObj[pathToDelete];\n    } else if (isArray(subObj) && !isNaN(pathToDelete)) {\n        subObj.splice(pathToDelete, 1);\n    }\n    return subObj;\n}\n", "import Symbolic from './symbolic.js';\nimport has from './has.js';\nimport { isFunction } from './types.js';\n\nconst SYM = Symbolic('listeners');\n\n/**\n * Add a callback for the specified trigger.\n *\n * @param {Object} scope The event scope\n * @param {String} name The event name\n * @param {Function} callback The callback function\n * @return {Function} Destroy created listener with this function\n */\nexport function on(scope, name, callback) {\n    if (!isFunction(callback)) {\n        throw new TypeError('callback is not a function');\n    }\n    scope[SYM] = scope[SYM] || {};\n    const callbacks = scope[SYM];\n    const evtCallbacks = callbacks[name] = callbacks[name] || [];\n    evtCallbacks.push(callback);\n    return off.bind(null, scope, name, callback);\n}\n\n/**\n * Remove one or multiple listeners.\n *\n * @param {Object} scope The event scope\n * @param {String} [name] Optional event name to reset\n * @param {Function} [callback] Callback to remove (empty, removes all listeners).\n */\nexport function off(scope, name, callback) {\n    if (callback) {\n        const callbacks = scope[SYM];\n        if (callbacks) {\n            const evtCallbacks = callbacks[name] = callbacks[name] || [];\n            const io = evtCallbacks.indexOf(callback);\n            if (io !== -1) {\n                evtCallbacks.splice(io, 1);\n            }\n        }\n    } else if (name) {\n        const callbacks = scope[SYM];\n        if (callbacks) {\n            delete callbacks[name];\n        }\n    } else {\n        scope[SYM] = {};\n    }\n}\n\n/**\n * Trigger a callback.\n *\n * @param {Object} scope The event scope\n * @param {String} name Event name\n * @param {...*} args Arguments to pass to callbacks\n * @return {Promise} The final Promise of the callbacks chain\n */\nexport function trigger(scope, name, ...args) {\n    const callbacksList = (has(scope, SYM) && has(scope[SYM], name) && scope[SYM][name]) || [];\n    const finalResults = callbacksList\n        .slice(0)\n        .reduce((results, callback) => {\n            if (callbacksList.indexOf(callback) === -1) {\n                // the callback has been removed from the callback list.\n                return results;\n            }\n            const lastResult = results[results.length - 1];\n            let result;\n            if (lastResult instanceof Promise) {\n                // wait for the previous result.\n                result = lastResult.then(() => callback.call(scope, ...args));\n            } else {\n                result = callback.call(scope, ...args);\n            }\n            results.push(result);\n            return results;\n        }, []);\n\n    return Promise.all(finalResults);\n}\n", "import { Emitter } from './factory.js';\nimport { isArray, isObject } from './types.js';\nimport { get, set, extend, reconstruct } from './proto.js';\nimport Symbolic from './symbolic.js';\n/**\n * @typedef ChangeSet\n * @property {String} property The path to the changed property.\n * @property {*} oldValue The old value for the property.\n * @property {*} newValue The new value for the property.\n * @property {Array} added A list of added items to an array.\n * @property {Array} remove A list of remove items from an array.\n */\n/**\n * Observable Symbol.\n * @type {Symbolic}\n * @private\n */\nconst OBSERVABLE_SYM = Symbolic('observable');\n/**\n * Array prototype shortcut.\n * @type {Object}\n * @private\n */\nconst ARRAY_PROTO = Array.prototype;\n/**\n * Object.prototype.hasOwnProperty shortcut.\n * @type {Function}\n * @private\n */\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n/**\n * Micro Proxy polyfill.\n * @private\n */\nconst ProxyHelper = typeof Proxy !== 'undefined' ? Proxy : class {\n    constructor(data, handler) {\n        const res = reconstruct(get(data));\n        Object.keys(data)\n            .filter((key) => Object.getOwnPropertyDescriptor(data, key).configurable)\n            .forEach((key) => {\n                this.define(res, data, key, handler);\n            });\n        if (isArray(data)) {\n            let lastLength = data.length;\n            res.on('change', () => {\n                if (data.length !== lastLength) {\n                    Object.keys(data).forEach((key) => {\n                        if (key !== OBSERVABLE_SYM) {\n                            this.define(res, data, key, handler);\n                        }\n                    });\n                    lastLength = data.length;\n                }\n            });\n        }\n        res[OBSERVABLE_SYM] = data[OBSERVABLE_SYM];\n        return res;\n    }\n    define(res, data, property, handler) {\n        const desc = {\n            configurable: true,\n            enumerable: ('enumerable' in handler) ? handler.enumerable : !Symbolic.isSymbolic(property),\n        };\n        if (handler.get) {\n            desc.get = () => handler.get(data, property);\n        }\n        if (handler.set) {\n            desc.set = (val) => handler.set(data, property, val);\n        }\n        Object.defineProperty(res, property, desc);\n    }\n};\n/**\n * Trigger object changes.\n * @private\n *\n * @param {Object|Array} scope The updated object.\n * @param {ChangeSet} changeset The changes descriptor.\n */\nfunction triggerChanges(scope, changeset) {\n    return scope[OBSERVABLE_SYM].trigger('change', changeset);\n}\n/**\n * Wrap Array prototype methods for changes triggering.\n * @type {Object}\n * @private\n */\nconst ARRAY_PROTO_WRAP = {\n    push(...items) {\n        const length = this.length;\n        items = items.map((item, index) =>\n            subobserve(this, length + index, item)\n        );\n        const res = ARRAY_PROTO.push.call(this, ...items);\n        triggerChanges(this, {\n            property: length,\n            added: items,\n            removed: [],\n        });\n        return res;\n    },\n    unshift(item) {\n        const res = ARRAY_PROTO.unshift.call(this, item);\n        subobserve(this, 0, item);\n        triggerChanges(this, {\n            property: 0,\n            added: [item],\n            removed: [],\n        });\n        return res;\n    },\n    pop() {\n        const res = ARRAY_PROTO.pop.call(this);\n        triggerChanges(this, {\n            property: this.length,\n            added: [],\n            removed: [res],\n        });\n        return res;\n    },\n    shift() {\n        const res = ARRAY_PROTO.shift.call(this);\n        triggerChanges(this, {\n            property: 0,\n            added: [],\n            removed: [res],\n        });\n        return res;\n    },\n    splice(index, count, ...items) {\n        items = items.map((item, index) =>\n            subobserve(this, length + index, item)\n        );\n        const res = ARRAY_PROTO.splice.call(this, index, count, ...items);\n        triggerChanges(this, {\n            property: index,\n            added: items,\n            removed: [res],\n        });\n        return res;\n    },\n};\n/**\n * Subobserve objects.\n * @private\n *\n * @param {Object|Array} target The root object.\n * @param {String} name The root object property name\n * @param {Object|Array} value The sub object to observe.\n * @return {Observable} The Observable instance for the sub object.\n */\nfunction subobserve(target, name, value) {\n    if (isObject(value) || isArray(value)) {\n        value = new Observable(value);\n        value.on('change', (changeset) => {\n            name = isArray(target) ? target.indexOf(value) : name;\n            const changes = {\n                property: `${name}.${changeset.property}`,\n            };\n            if (hasOwnProperty.call(changeset, 'value')) {\n                changes.oldValue = changeset.oldValue;\n                changes.value = changeset.value;\n            } else if (hasOwnProperty.call(changeset, 'added')) {\n                changes.added = changeset.added;\n                changes.removed = changeset.removed;\n            }\n            triggerChanges(target, changes);\n        });\n    }\n    return value;\n}\n/**\n * ES6 Proxy handler.\n * @type {Object}\n * @private\n */\nconst handler = {\n    getPrototypeOf(target) {\n        if (isArray(target)) {\n            return target.constructor.prototype;\n        }\n        return Reflect.getPrototypeOf(target);\n    },\n    get: (target, name) => target[name],\n    set: (target, name, value) => {\n        if (Symbolic.isSymbolic(name)) {\n            return target[name] = value;\n        }\n        const oldValue = target[name];\n        if (target[name] !== value) {\n            value = subobserve(target, name, value);\n            target[name] = value;\n            triggerChanges(target, {\n                property: name,\n                oldValue,\n                value,\n            });\n        }\n        return true;\n    },\n};\n/**\n * Create an Observable object for a set of data or an array.\n *\n * @param {Object|Array} data The object to observe.\n * @return {Proxy} The observed object proxy.\n */\nexport default class Observable {\n    constructor(data) {\n        if (typeof data !== 'object') {\n            throw new Error('Cannot observe this value.');\n        }\n        const emitter = data[OBSERVABLE_SYM] || new Emitter();\n\n        if (emitter.proxy) {\n            return emitter.proxy;\n        }\n        const proto = {\n            on: { value: emitter.on.bind(emitter) },\n            off: { value: emitter.off.bind(emitter) },\n            trigger: { value: emitter.trigger.bind(emitter) },\n        };\n        if (isArray(data)) {\n            proto.push = { get: () => ARRAY_PROTO_WRAP.push.bind(data) };\n            proto.unshift = { get: () => ARRAY_PROTO_WRAP.unshift.bind(data) };\n            proto.pop = { get: () => ARRAY_PROTO_WRAP.pop.bind(data) };\n            proto.shift = { get: () => ARRAY_PROTO_WRAP.shift.bind(data) };\n            proto.splice = { get: () => ARRAY_PROTO_WRAP.splice.bind(data) };\n        }\n        data[OBSERVABLE_SYM] = emitter;\n        set(data, extend(get(data), proto));\n        emitter.proxy = new ProxyHelper(data, handler);\n        Object.keys(data).forEach((key) => {\n            if (key !== OBSERVABLE_SYM) {\n                data[key] = subobserve(data, key, data[key]);\n            }\n        });\n        return emitter.proxy;\n    }\n    /**\n     * Re-observe an array or an object after adding a property.\n     *\n     * You should invoke this static method only after adding a new property\n     * to an object, and only if you wish to support browsers that do not have\n     * native Proxy object. This is required because it is impossible to\n     * intercept new properties added to an existing object from the polyfill.\n     *\n     * ## Example\n     *\n     * ```js\n     * const myObservable = new Observable({ foo: 'foo' });\n     *\n     * // This is not enough to trigger changes in older browsers!\n     * myObservable.bar = 'bar';\n     *\n     * // So, you should invoke this immediately after:\n     * Observable.reobserve(myObservable);\n     * ```\n     *\n     * @param {Object|Array} data Data to be re-observed.\n     * @return {void}\n     */\n    static reobserve(data) {\n        if (typeof Proxy !== 'undefined') {\n            // Native proxy support. We're good.\n            return;\n        }\n        // Ensure `data` is an observable.\n        new Observable(data);\n        Object.keys(data).forEach((key) => {\n            const descriptor = Object.getOwnPropertyDescriptor(data, key);\n            if (key !== OBSERVABLE_SYM && descriptor && descriptor.configurable && ('value' in descriptor)) {\n                // Key has been added and is not yet observed. Big Brother is on its way.\n                data[key] = subobserve(data, key, data[key]);\n                triggerChanges(data, {\n                    property: key,\n                    oldValue: undefined,\n                    value: data[key],\n                });\n            }\n        });\n    }\n}\n", "/**\n * @module Url\n */\n\nimport * as keypath from './keypath.js';\nimport Symbolic from './symbolic.js';\nimport has from './has.js';\n\nconst REF_SYM = Symbolic('ref');\nconst URL_REGEX = /((?:^(?:[a-z]+:))|^)?(?:\\/\\/)?([^?/$]*)([^?]*)?(\\?.*)?/i;\nconst PORT_REGEX = /:\\d*$/;\n\n/**\n * Parse and split an url in its components.\n *\n * @param {string} url The url to parse.\n * @return {Object} The url properties.\n */\nexport function parse(url = '') {\n    const hashSplit = url.split('#');\n    const hash = hashSplit.length > 1 ? hashSplit.pop() : undefined;\n    url = hashSplit.join('#');\n    const match = url.match(URL_REGEX);\n    const res = {\n        host: undefined,\n        hostname: undefined,\n        port: undefined,\n        username: undefined,\n        password: undefined,\n        hash,\n    };\n    if (match) {\n        res.protocol = match[1];\n        if (match[2]) {\n            let host = match[2];\n            res.host = host;\n            const port = host.match(PORT_REGEX);\n            if (port) {\n                res.port = port[0].substring(1);\n                host = host.replace(port[0], '');\n            }\n            const authSplit = host.split('@');\n            res.hostname = authSplit.pop();\n            const authChunk = authSplit.join('@').split(':');\n            res.username = authChunk.shift();\n            res.password = authChunk.join(':');\n        }\n        res.pathname = match[3];\n        res.search = match[4];\n    }\n    if (!match ||\n        (res.port && !res.hostname) ||\n        (res.protocol && res.protocol !== 'file:' && !res.hostname) ||\n        (res.search && !res.hostname && !res.pathname) ||\n        (res.password && !res.username)\n    ) {\n        throw new SyntaxError('invalid url');\n    }\n    if (res.host && res.pathname === '/') {\n        res.pathname = '';\n    }\n    if (res.hostname) {\n        let origin = res.protocol ? `${res.protocol}//` : '';\n        origin += res.hostname;\n        origin += res.port ? `:${res.port}` : '';\n        res.origin = origin;\n    }\n    return res;\n}\n\n/**\n * Serialize a key/value pair matching differente operators.\n *\n * @param {string} key The pair key.\n * @param {string} val The pair value.\n * @return {string} A serialized string of key/value pair.\n */\nfunction chunk(key, val) {\n    if (val) {\n        return `${encodeURIComponent(key)}=${encodeURIComponent(val)}`;\n    }\n    return `${encodeURIComponent(key)}`;\n}\n\n/**\n * Serialize an object in FormData format.\n *\n * @param {Object} obj The object to convert.\n * @param {string} prefix The prefix to use in case of recursion.\n * @param {Function} [chunkFn] The callback function to use for chunking a key/value pair.\n * @return {string} An object to serialize.\n */\nexport function serialize(obj, prefix, chunkFn = chunk) {\n    const str = [];\n    const keys = Object.keys(obj);\n    if (keys.length) {\n        for (const p in obj) {\n            if (has(obj, p) && obj[p] !== undefined) {\n                const k = prefix ? `${prefix}[${p}]` : p;\n                let v = obj[p];\n                if (v instanceof Date) {\n                    v = v.toISOString();\n                }\n                str.push(\n                    (v !== null && typeof v === 'object') ?\n                        serialize(v, k) :\n                        chunkFn(k, `${v}`)\n                );\n            }\n        }\n    } else if (prefix) {\n        str.push(chunkFn(prefix));\n    }\n    return str.join('&');\n}\n\n/**\n * Unserialize a string in FormData format to an object.\n *\n * @param {string} str A search string to unserialize.\n * @return {object} The unserialized object.\n */\nexport function unserialize(str) {\n    str = decodeURI(str);\n    const chunks = str.split('&');\n    const res = {};\n\n    for (let i = 0, len = chunks.length; i < len; i++) {\n        const chunk = chunks[i].split('=');\n        if (chunk[0] && chunk[1]) {\n            const key = chunk[0].replace(/\\[(.*?)\\]/g, '.$1');\n            const val = decodeURIComponent(chunk[1]);\n            keypath.set(res, key, val);\n        }\n    }\n\n    return res;\n}\n\n/**\n * Join url paths.\n *\n * @param {...string} paths A list of paths to join.\n * @return {string} The final join string.\n */\nexport function join(...paths) {\n    return paths\n        .map((path) => (path || '').replace(/^\\/*/, '').replace(/\\/*$/, ''))\n        .filter((path) => !!path)\n        .join('/');\n}\n\n/**\n * Resolve relative url path.\n *\n * @param {string} base The base path.\n * @param {string} relative The relative path.\n * @return {string} The rsolved path.\n */\nexport function resolve(base, relative) {\n    if (relative[0] === '/') {\n        const baseInfo = parse(base);\n        if (!baseInfo.origin) {\n            throw new Error('base url is not an absolute url');\n        }\n        base = `${baseInfo.origin}/`;\n    }\n    const stack = base.split('/');\n    const parts = relative.split('/').filter((part) => part !== '');\n    if (stack.length > 1) {\n        stack.pop();\n    }\n    for (let i = 0; i < parts.length; i++) {\n        if (parts[i] === '.') {\n            continue;\n        } else if (parts[i] === '..') {\n            stack.pop();\n        } else {\n            stack.push(parts[i]);\n        }\n    }\n    return stack.join('/');\n}\n\n/**\n * Check if an url is absolute.\n *\n * @param {string} url The url to check.\n * @return {boolean}\n */\nexport function isAbsoluteUrl(url) {\n    return !!parse(url).protocol;\n}\n\n/**\n * Check if an url is a data url.\n *\n * @param {string} url The url to check.\n * @return {boolean}\n */\nexport function isDataUrl(url) {\n    return parse(url).protocol === 'data:';\n}\n\n/**\n * Check if an url points to a local file.\n *\n * @param {string} url The url to check.\n * @return {boolean}\n */\nexport function isLocalUrl(url) {\n    return parse(url).protocol === 'file:';\n}\n\n/**\n * Update query string params to an url\n *\n * @param {Url} url The url to update.\n * @param {string} path The query string.\n * @return {string}\n */\nfunction updateSearchPath(url, path) {\n    const href = url.href.split('?')[0];\n    if (!path) {\n        return url.href = href;\n    }\n    return url.href = `${href}?${path}`;\n}\n\n/**\n * Convert search params entries to a query string.\n *\n * @param {Array} entries Search params entries.\n * @return {string} The query string.\n */\nfunction entriesToString(entries) {\n    const unserialized = {};\n    entries.forEach((entry) => {\n        unserialized[entry[0]] = entry[1];\n    });\n    return serialize(unserialized);\n}\n\n/**\n * Search params interface for Url.\n */\nexport class SearchParams {\n    /**\n     * Create search params instance.\n     * @param {Url} ref The referenced Url instance.\n     */\n    constructor(ref) {\n        this[REF_SYM] = ref;\n    }\n\n    /**\n     * The referenced Url.\n     * @type {Url}\n     */\n    get url() {\n        return this[REF_SYM];\n    }\n\n    /**\n     * List all entry keys.\n     *\n     * @return {Array} Entry keys list.\n     */\n    keys() {\n        return this.entries()\n            .map((entry) => entry[0]);\n    }\n\n    /**\n     * List all entry values.\n     *\n     * @return {Array} Entry values list.\n     */\n    values() {\n        return this.entries()\n            .map((entry) => entry[1]);\n    }\n\n    /**\n     * List all entries.\n     *\n     * @return {Array} Entries list in format [[key, value], [...]].\n     */\n    entries() {\n        if (!this.url.search) {\n            return [];\n        }\n        const search = this.url.search.substring(1);\n        const unserialized = unserialize(search);\n        return Object.keys(unserialized)\n            .map((key) => [key, unserialized[key]]);\n    }\n\n    /**\n     * Retrieve an entry.\n     *\n     * @param {string} name The entity name to get.\n     * @return {*} The entity value.\n     */\n    get(name) {\n        const entries = this.entries();\n        for (let i = 0, len = entries.length; i < len; i++) {\n            if (entries[i][0] === name) {\n                return entries[i][1];\n            }\n        }\n    }\n\n    /**\n     * Check if entity is defined.\n     *\n     * @param {string} name The entity name to check.\n     * @return {Boolean}\n     */\n    has(name) {\n        return !!this.get(name);\n    }\n\n    /**\n     * Set an entry value.\n     *\n     * @param {string} name The entity name to set.\n     * @param {*} value The entity value to set\n     */\n    set(name, value) {\n        this.delete(name);\n        const entries = this.entries();\n        entries.push([name, value]);\n        updateSearchPath(\n            this.url,\n            entriesToString(entries)\n        );\n    }\n\n    /**\n     * Remove an entity from the search params.\n     *\n     * @param {string} name The entity name to remove.\n     */\n    delete(name) {\n        updateSearchPath(\n            this.url,\n            entriesToString(\n                this.entries().filter((entry) => entry[0] !== name)\n            )\n        );\n    }\n\n    /**\n     * Sort entities by keys names.\n     */\n    sort() {\n        const entries = this.entries();\n        entries.sort((entry1, entry2) => {\n            const key1 = entry1[0];\n            const key2 = entry2[0];\n            if (key1 < key2) {\n                return -1;\n            } else if (key1 > key2) {\n                return 1;\n            }\n            return 0;\n        });\n        updateSearchPath(this.url, entriesToString(entries));\n    }\n\n    toString() {\n        return this.url.search;\n    }\n}\n\n/**\n * Url helper class.\n */\nexport class Url {\n    /**\n     * Create a Url instance.\n     * @param {string} path The url to handle.\n     * @param {string} [baseUrl] The optional base url.\n     */\n    constructor(path, baseUrl) {\n        /**\n         * The url's protocol (if defined).\n         * @type {string|undefined}\n         */\n        this.protocol = undefined;\n        /**\n         * The username used (if defined).\n         * @type {string|undefined}\n         */\n        this.username = undefined;\n        /**\n         * The password used (if defined).\n         * @type {string|undefined}\n         */\n        this.password = undefined;\n        /**\n         * The url's host.\n         * @type {string|undefined}\n         */\n        this.host = undefined;\n        /**\n         * The url's hostname.\n         * @type {string|undefined}\n         */\n        this.hostname = undefined;\n        /**\n         * The url's pathname.\n         * @type {string|undefined}\n         */\n        this.pathname = undefined;\n        /**\n         * The url's port (if defined).\n         * @type {string|undefined}\n         */\n        this.port = undefined;\n        /**\n         * The url's query params.\n         * @type {string|undefined}\n         */\n        this.search = undefined;\n        /** The url's hash.\n         * @type {string|undefined}\n         */\n        this.hash = undefined;\n        /**\n         * The full url string.\n         * @type {string}\n        */\n        this.href = baseUrl ? resolve(baseUrl, path) : path;\n        /**\n         * The url query string interface.\n         * @type {SearchParams}\n         */\n        this.searchParams = new SearchParams(this);\n    }\n\n    get href() {\n        return this[REF_SYM];\n    }\n\n    set href(href) {\n        const info = parse(href);\n        this[REF_SYM] = href;\n        for (const k in info) {\n            this[k] = info[k];\n        }\n    }\n\n    /**\n     * Join current Url with paths.\n     *\n     * @param {...string} paths A list of paths to join.\n     * @return {Url} A new url instance.\n     */\n    join(...paths) {\n        return new Url(join(this.href, ...paths));\n    }\n\n    /**\n     * Resolve a path relative to the current Url.\n     *\n     * @param {string} path The relative path.\n     * @return {Url} A new url instance.\n     */\n    resolve(path) {\n        return new Url(resolve(this.href, path));\n    }\n\n    /**\n     * Check if current Url is absolute.\n     *\n     * @return {Boolean}\n     */\n    isAbsoluteUrl() {\n        return isAbsoluteUrl(this.href);\n    }\n\n    /**\n     * Check if current Url is a data url.\n     *\n     * @return {Boolean}\n     */\n    isDataUrl() {\n        return isDataUrl(this.href);\n    }\n\n    /**\n     * Check if current Url points to local file.\n     *\n     * @return {Boolean}\n     */\n    isLocalUrl() {\n        return isLocalUrl(this.href);\n    }\n\n    toString() {\n        return this.href;\n    }\n}\n"],
  "mappings": "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",
  "names": []
}
