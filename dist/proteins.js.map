{
  "version": 3,
  "sources": ["../src/types.js", "../src/proto.js", "../src/has.js", "../src/_helpers.js", "../src/clone.js", "../src/merge.js", "../src/equivalent.js", "../src/symbolic.js", "../src/mixin.js", "../src/factory.js", "../src/keypath.js", "../src/events.js", "../src/observable.js", "../src/url.js", "../src/pool.js"],
  "sourcesContent": ["/**\n * Check if a value is a function.\n *\n * @param {*} obj The value to check.\n * @return {Boolean}\n */\nexport function isFunction(obj) {\n    return typeof obj === 'function';\n}\n/**\n * Check if a value is a string.\n *\n * @param {*} obj The value to check.\n * @return {Boolean}\n */\nexport function isString(obj) {\n    return typeof obj === 'string';\n}\n/**\n * Check if a value is a number.\n *\n * @param {*} obj The value to check.\n * @return {Boolean}\n */\nexport function isNumber(obj) {\n    return typeof obj === 'number' && !isNaN(obj);\n}\n/**\n * Check if a value is a bool.\n *\n * @param {*} obj The value to check.\n * @return {Boolean}\n */\nexport function isBoolean(obj) {\n    return typeof obj === 'boolean';\n}\n/**\n * Check if a value is a date.\n *\n * @param {*} obj The value to check.\n * @return {Boolean}\n */\nexport function isDate(obj) {\n    return obj instanceof Date;\n}\n/**\n * Check if a value is an object.\n *\n * @param {*} obj The value to check.\n * @return {Boolean}\n */\nexport function isObject(obj) {\n    return Object.prototype.toString.call(obj) === '[object Object]';\n}\n/**\n * Check if a value is undefined.\n *\n * @param {*} obj The value to check.\n * @return {Boolean}\n */\nexport function isUndefined(obj) {\n    return typeof obj === 'undefined';\n}\n/**\n * Check if a value is an array.\n *\n * @param {*} obj The value to check.\n * @return {Boolean}\n */\nexport function isArray(obj) {\n    return Array.isArray(obj) || obj instanceof Array;\n}\n/**\n * Check if falsy value.\n *\n * @param {*} obj The value to check.\n * @return {Boolean}\n */\nexport function isFalsy(obj) {\n    return isUndefined(obj) || obj === null || obj === false || (typeof obj === 'number' && isNaN(obj));\n}\n\n/**\n * Check if input is iterable.\n * @param {*} input\n * @returns {input is Iterable<any>} True if input is iterable.\n */\nexport function isIterable(input) {\n    if (input == null || typeof input !== 'object') {\n        return false;\n    }\n\n    return typeof input[Symbol.iterator] === 'function';\n}\n", "/**\n * @module Proto\n */\n\nimport { isFunction, isObject, isArray } from './types.js';\nimport hasOwnProperty from './has.js';\n\nconst getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nconst create = Object.create;\n\n/**\n * Iterate all prototype chain of a class.\n * @memberof Proto\n *\n * @param {Function} Ctr The class to iterate.\n * @param {Function} [callback] A callback function for each prototype.\n * @return {Array<string>}\n */\nexport function walk(Ctr, callback) {\n    let proto = Ctr.prototype;\n    while (proto) {\n        callback(proto);\n        proto = Object.getPrototypeOf(proto.constructor).prototype;\n    }\n}\n\n/**\n * Retrieve a list of properties and methods (with their descriptors) for the class.\n * @memberof Proto\n *\n * @param {Function} Ctr The class to analyze.\n * @param {Function} [filter] A filter function for the property.\n * @return {Object}\n */\nexport function entries(Ctr, filter = () => true) {\n    const res = {};\n    walk(Ctr, (proto) => {\n        Object.getOwnPropertyNames(proto)\n            .forEach((key) => {\n                if (!hasOwnProperty(res, key)) {\n                    const descriptor = getOwnPropertyDescriptor(proto, key);\n                    if (filter(key, descriptor)) {\n                        res[key] = descriptor;\n                    }\n                }\n            });\n    });\n    return res;\n}\n\n/**\n * Retrieve definitions of methods for the class.\n * @memberof Proto\n *\n * @param {Function} Ctr The class to analyze.\n * @return {Array<string>}\n */\nexport function methods(Ctr) {\n    return entries(Ctr, (key, descriptor) => isFunction(descriptor.value) && key !== 'constructor');\n}\n\n/**\n * Retrieve definitions of properties for the class.\n * @memberof Proto\n *\n * @param {Function} Ctr The class to analyze.\n */\nexport function properties(Ctr) {\n    return entries(Ctr, (key, descriptor) => !isFunction(descriptor.value));\n}\n\n/**\n * Get all definitions for a given property in the prototype chain.\n * @memberof Proto\n *\n * @param {Function} Ctr The class to analyze.\n * @param {string} property The property name to collect.\n * @return {Array<Object>}\n */\nexport function reduce(Ctr, property) {\n    const res = [];\n    walk(Ctr, (proto) => {\n        const descriptor = getOwnPropertyDescriptor(proto, property);\n        if (descriptor) {\n            res.push(descriptor);\n        }\n    });\n    return res;\n}\n\n/**\n * Check if a method or a property is in the prototype chain.\n * @memberof Proto\n *\n * @param {Function} Ctr The class to analyze.\n * @param {string} property The property name to verify.\n * @return {Boolean}\n */\nexport function has(Ctr, property) {\n    return !!reduce(Ctr, property).length;\n}\n\n/**\n * Retrieve prototype of an object.\n * @memberof Proto\n *\n * @param {Object} obj The object to analyze.\n * @return {Object} The prototype.\n */\nexport function get(obj) {\n    if (Object.getPrototypeOf) {\n        return Object.getPrototypeOf(obj);\n    }\n    if (isObject(obj.__proto__)) {\n        return obj.__proto__;\n    }\n    return obj.constructor.prototype;\n}\n\n/**\n * Set prototype to an object.\n * @memberof Proto\n *\n * @param {Object} obj The object to update.\n * @param {Object|Function} proto The prototype or the class to use.\n */\nexport function set(obj, proto) {\n    if (!isFunction(obj) && isFunction(proto)) {\n        proto = proto.prototype;\n    }\n    Object.setPrototypeOf ?\n        Object.setPrototypeOf(obj, proto) :\n        obj.__proto__ = proto;\n}\n\n/**\n * Extend a prototype.\n * @memberof Proto\n *\n * @param {Object} proto1 The prototype to extend.\n * @param {Object} proto2 The prototype to use.\n * @return {Object} The new prototype.\n */\nexport function extend(proto1, proto2) {\n    if (isFunction(proto1)) {\n        proto1 = proto1.prototype;\n    }\n    if (isFunction(proto2)) {\n        proto2 = proto2.prototype;\n    }\n    return create(proto1, proto2);\n}\n\n/**\n * Create a new instance of an object without constructor.\n * @memberof Proto\n *\n * @param {Function|Object} Ctr The class or the prototype to reconstruct.\n * @return {Object} The new instance.\n */\nexport function reconstruct(Ctr) {\n    if (isFunction(Ctr)) {\n        return reconstruct(Ctr.prototype);\n    } else if (isArray(Ctr)) {\n        const res = [];\n        set(res, Ctr);\n        return res;\n    }\n    return create(Ctr);\n}\n", "/**\n * Exec Object.prototype.hasOwnProperty against an object.\n * @param {Object} scope The scope object to check.\n * @param {string} property The property name to check.\n * @return {boolean}\n */\nexport default function has(scope, property) {\n    return Object.prototype.hasOwnProperty.call(scope, property);\n}\n", "import { isArray } from './types.js';\n\n/**\n * Get object's property descriptors.\n * This method is compatible with IE 11, Safari 9 and Chrome older than 54,\n * `Object.getOwnPropertyDescriptors` isn't.\n *\n * @param {Object} obj The Object.\n * @return {Object} Descriptors' map.\n */\nexport function getDescriptors(obj) {\n    return Object.getOwnPropertyNames(obj)\n        .reduce((acc, propName) => {\n            acc[propName] = Object.getOwnPropertyDescriptor(obj, propName);\n            return acc;\n        }, {});\n}\n\n/**\n * Build a new configurable descriptor starting from passed `descriptor`.\n * @param {Object} descriptor The descriptor to clone.\n * @param {*} val The value to set as `value` descriptor property.\n * @param {boolean} writable Writable configuration of the descriptor.\n * @return {Object} New descriptor.\n */\nexport function buildDescriptor(descriptor, val, writable = true) {\n    const newDescriptor = {\n        configurable: true,\n        enumerable: descriptor.enumerable,\n    };\n    if (descriptor.get || descriptor.set) {\n        newDescriptor.get = descriptor.get;\n        newDescriptor.set = descriptor.set;\n    } else {\n        // `value` and `writable` are allowed in a descriptor only when there isn't a getter/setter.\n        newDescriptor.value = val;\n        newDescriptor.writable = writable;\n    }\n    return newDescriptor;\n}\n\n/**\n * Object.entries ponyfill.\n */\nexport const entries = Object.entries || ((obj) => Object.keys(obj).map((key) => [key, obj[key]]));\n\n/**\n * Array.prototype.flat ponyfill.\n */\nexport const flat = Array.prototype.flat || function() {\n    return this.reduce((acc, item) => {\n        if (isArray(item)) {\n            return acc.concat(flat.call(item));\n        }\n        return acc.concat([item]);\n    }, []);\n};\n", "import { isObject, isDate, isArray, isFunction } from './types.js';\nimport { get, reconstruct } from './proto.js';\nimport { getDescriptors, buildDescriptor } from './_helpers.js';\n\n/**\n * Useless callback function.\n * @private\n *\n * @param {*} scope The current object.\n * @param {string} key The current key.\n * @param {*} prop The current value.\n */\nfunction noop(scope, key, prop) { return prop; }\n\n/**\n * Clone an object.\n *\n * @method clone\n * @param {*} obj The instance to clone.\n * @param {Function} [callback] A modifier function for each property.\n * @param {boolean} [useStrict] Should preserve frozen and sealed objects.\n * @param {WeakMap} [cache] The cache for circular references.\n * @return {*} The clone of the object.\n */\nexport default function clone(obj, callback = noop, useStrict = false, cache = new WeakMap()) {\n    if (typeof callback === 'boolean') {\n        useStrict = callback;\n        callback = noop;\n    }\n    if (isObject(obj) || isArray(obj)) {\n        if (cache.has(obj)) {\n            return cache.get(obj);\n        }\n        const res = reconstruct(get(obj));\n        cache.set(obj, res);\n        const newDescriptors = getDescriptors(res);\n        const descriptors = getDescriptors(obj);\n        for (const key in descriptors) {\n            const descriptor = descriptors[key];\n            if (newDescriptors[key] && !newDescriptors[key].configurable) {\n                continue;\n            }\n            let value;\n            if ('value' in descriptor) {\n                value = callback(obj, key, clone(descriptor.value, callback, useStrict, cache));\n            }\n            Object.defineProperty(res, key, buildDescriptor(descriptor, value, useStrict ? descriptor.writable : true));\n        }\n        if (useStrict) {\n            if (Object.isFrozen(obj)) {\n                Object.freeze(res);\n            } else if (Object.isSealed(obj)) {\n                Object.seal(res);\n            }\n        }\n        return res;\n    } else if (isDate(obj)) {\n        return new Date(obj.getTime());\n    } else if (isFunction(obj)) {\n        return obj;\n    }\n    return obj;\n}\n", "import clone from './clone.js';\nimport { getDescriptors, buildDescriptor } from './_helpers.js';\nimport { isObject, isArray } from './types.js';\n\nconst defaults = {\n    mergeObjects: true,\n    joinArrays: false,\n    strictMerge: false,\n};\n\n/**\n * Merge two objects into a new one.\n *\n * @method merge\n * @param {...Object|Array} objects The objects to merge.\n * @return {Object} The merged object.\n */\nexport default function merge(...objects) {\n    let options = defaults;\n    if (typeof this !== 'undefined' && this.options) {\n        options = this.options;\n    }\n    const first = objects.shift();\n    const res = clone(first);\n\n    objects.forEach((obj2) => {\n        if (isObject(first) && isObject(obj2)) {\n            const descriptors = getDescriptors(obj2);\n            Object.keys(descriptors).forEach((key) => {\n                const leftDescriptor = Object.getOwnPropertyDescriptor(first, key);\n                const rightDescriptor = descriptors[key];\n                if (!('value' in rightDescriptor)) {\n                    Object.defineProperty(res, key, buildDescriptor(rightDescriptor));\n                    return;\n                }\n\n                if (options.strictMerge) {\n                    if (!leftDescriptor) {\n                        return;\n                    }\n                    if (typeof leftDescriptor.get !== typeof rightDescriptor.get) {\n                        return;\n                    }\n                    if (typeof leftDescriptor.set !== typeof rightDescriptor.set) {\n                        return;\n                    }\n                }\n\n                let rightVal = clone(rightDescriptor.value);\n                if (leftDescriptor && rightVal) {\n                    const leftVal = leftDescriptor.value;\n                    if (isObject(leftVal) && isObject(rightVal) && options.mergeObjects) {\n                        rightVal = merge.call(this, leftVal, rightVal);\n                    } else if (isArray(leftVal) && isArray(rightVal) && options.joinArrays) {\n                        rightVal = merge.call(this, leftVal, rightVal);\n                    }\n                }\n                Object.defineProperty(res, key, buildDescriptor(rightDescriptor, rightVal));\n            });\n        } else if (isArray(first) && isArray(obj2)) {\n            const descriptors = getDescriptors(obj2);\n            // Skip length descriptor.\n            delete descriptors.length;\n            Object.keys(descriptors).forEach((key) => {\n                const rightDescriptor = descriptors[key];\n                if (!('value' in rightDescriptor)) {\n                    Object.defineProperty(res, key, buildDescriptor(rightDescriptor));\n                    return;\n                }\n\n                const leftVal = first[key];\n                let rightVal = clone(rightDescriptor.value);\n                if (!isNaN(key)) {\n                    if (options.joinArrays) {\n                        // check if already in the left array\n                        if (first.indexOf(rightVal) === -1) {\n                            // append the value instead of overwriting\n                            res.push(rightVal);\n                        }\n                        return;\n                    }\n\n                    if (isObject(leftVal) && isObject(rightVal) && options.mergeObjects) {\n                        rightVal = merge.call(this, leftVal, rightVal);\n                    } else if (isArray(leftVal) && isArray(rightVal)) {\n                        rightVal = merge.call(this, leftVal, rightVal);\n                    }\n                }\n                Object.defineProperty(res, key, buildDescriptor(rightDescriptor, rightVal));\n            });\n        } else {\n            throw 'incompatible types';\n        }\n    });\n    return res;\n}\n\n/**\n * Create a new Merge function with passed options.\n *\n * @method config\n * @memberof merge\n * @param {Object} options Merge options.\n * @param {Boolean} options.mergeObjects Should ricursively merge objects keys.\n * @param {Boolean} options.joinArrays Should join arrays instead of update keys.\n * @param {Boolean} options.strictMerge Should merge only keys which already are in the first object.\n * @return {Function} The new merge function.\n */\nmerge.config = function(options = {}) {\n    return (...args) => merge.call({\n        options: merge(defaults, options),\n    }, ...args);\n};\n", "import { isObject, isDate, isArray, isFunction } from './types.js';\n\n/**\n * Internal objects equivalence check.\n * @private\n * @param {*} obj1 The original object.\n * @param {*} obj2 The object to compare\n * @param {Array} [processing] A list of already processed comparisons.\n * @return {Boolean}\n */\nfunction internalEquivalent(obj1, obj2, processing = []) {\n    if (typeof obj1 === typeof obj2) {\n        if (isArray(obj1)) {\n            if (obj1.length === obj2.length) {\n                // Arrays have the same length\n                for (let i = 0, len = obj1.length; i < len; i++) {\n                    if (!internalEquivalent(obj1[i], obj2[i], processing)) {\n                        // Deep check failed.\n                        return false;\n                    }\n                }\n                return true;\n            }\n            return false;\n        } else if (isObject(obj1)) {\n            // handle multiple object instance check.\n            let processSourceIndex = processing.indexOf(obj1);\n            while (processSourceIndex !== -1) {\n                // `processing` array contains pairs of compared object, so left objects have always even index\n                if (processSourceIndex % 2 === 0 && processing[processSourceIndex + 1] === obj2) {\n                    // The comparison between the two objects has been already handled before.\n                    return true;\n                }\n                // The same object could be compared more than once, so we have to check for all references.\n                processSourceIndex = processing.indexOf(obj1, processSourceIndex);\n            }\n            processing.push(obj1, obj2);\n            const sourceKeys = Object.keys(obj1).sort();\n            const targetKeys = Object.keys(obj2).sort();\n            if (internalEquivalent(sourceKeys, targetKeys)) {\n                // objects keys are equivalent.\n                for (let i = 0, len = sourceKeys.length; i < len; i++) {\n                    const key = sourceKeys[i];\n                    if (!internalEquivalent(obj1[key], obj2[key], processing)) {\n                        // deep check failed.\n                        return false;\n                    }\n                }\n                return true;\n            }\n            return false;\n        } else if (isDate(obj1) && isDate(obj2)) {\n            // We cannot compare two dates just using `===`, so we use their timestamps.\n            return obj1.getTime() === obj2.getTime();\n        } else if (isFunction(obj1.valueOf) && isFunction(obj2.valueOf)) {\n            // Use `valueOf` method if available.\n            return obj1.valueOf() === obj2.valueOf();\n        }\n        // Generic check.\n        return obj1 === obj2;\n    }\n    // Comparison failed because object types mismatch.\n    return false;\n}\n\n/**\n * Recursive objects equivalence check.\n * @param {*} obj1 The original object.\n * @param {*} obj2 The object to compare\n * @return {Boolean}\n */\nexport default function equivalent(obj1, obj2) {\n    return internalEquivalent(obj1, obj2);\n}\n", "const support = (typeof Symbol === 'function');\n\n/**\n * Polyfill registry for symbols.\n * @private\n * @type {Array}\n */\nconst registry = [];\n\n/**\n * Polyfill for Symbol.\n * @class SymbolPolyfill\n * @private\n *\n * @param {string} property The Symbol name.\n */\nclass SymbolPolyfill {\n    constructor(property) {\n        const sym = this.SYM = `__${property}_${registry.length}`;\n        registry.push(sym);\n        Object.defineProperty(Object.prototype, sym, {\n            configurable: true,\n            enumerable: false,\n            set(x) {\n                Object.defineProperty(this, sym, {\n                    configurable: true,\n                    enumerable: false,\n                    writable: true,\n                    value: x,\n                });\n            },\n        });\n    }\n\n    toString() {\n        return this.SYM;\n    }\n}\n\n/**\n * Create a symbolic key for objects's properties.\n *\n * @param {string} property The Symbol name.\n * @return {Symbol|Symbolic}\n */\nexport default function Symbolic(property) {\n    if (support) {\n        // native Symbol support.\n        const sym = Symbol(property);\n        registry.push(sym);\n        return sym;\n    }\n    return new SymbolPolyfill(property);\n}\n\n/**\n * Check if an instance is a Symbol.\n * @param {Symbol|Symbolic} sym The symbol to check.\n * @return {Boolean}\n */\nSymbolic.isSymbolic = function(sym) {\n    if (!sym) {\n        return false;\n    }\n    if (sym instanceof SymbolPolyfill) {\n        sym = sym.toString();\n    }\n    return registry.indexOf(sym) !== -1;\n};\n", "import Symbolic from './symbolic.js';\nimport hasOwnProperty from './has.js';\n\nconst MIXINS_SYM = Symbolic('mixins');\n\n/**\n * Mix a class with a mixin.\n * Inspired by Justin Fagnani (https://github.com/justinfagnani).\n *\n * @param {Function} SuperClass The class to extend.\n * @return {MixinScope} A MixinScope instance.\n */\nexport default function mix(SuperClass) {\n    return new MixinScope(SuperClass);\n}\n\n/**\n * A Mixin helper class.\n */\nexport class MixinScope {\n    /**\n     * Create a mixable class.\n     * @param {Function} superClass The class to extend.\n     */\n    constructor(superClass) {\n        this.superClass = superClass || class { };\n    }\n    /**\n     * Mix the super class with a list of mixins.\n     *\n     * @param {...Function} mixins *N* mixin functions.\n     * @return {*} The extended class.\n     */\n    with(...mixins) {\n        let Class = this.superClass;\n        mixins.forEach((mixin) => {\n            if (!this.has(mixin)) {\n                Class = mixin(Class);\n            }\n        });\n        Class[MIXINS_SYM] = hasOwnProperty(Class, MIXINS_SYM) ? Class[MIXINS_SYM] : [];\n        Class[MIXINS_SYM].push(...mixins);\n        return Class;\n    }\n    /**\n     * Check if the SuperClass has been already mixed with a mixin function.\n     *\n     * @param {Function} mixin The mixin function.\n     * @return {Boolean}\n     */\n    has(mixin) {\n        let Class = this.superClass;\n        while (Class && Class !== Object) {\n            const attached = Class[MIXINS_SYM] || [];\n            if (attached.indexOf(mixin) !== -1) {\n                return true;\n            }\n            Class = Object.getPrototypeOf(Class);\n        }\n        return false;\n    }\n}\n", "/**\n * A set of classes with super powers.\n * For direct or extended use.\n *\n * @module Factory\n */\n\nimport mix from './mixin.js';\nimport Symbolic from './symbolic.js';\nimport * as keypath from './keypath.js';\nimport clone from './clone.js';\nimport merge from './merge.js';\nimport hasOwnProperty from './has.js';\nimport { isObject, isString } from './types.js';\nimport { on, off, trigger } from './events.js';\nimport { has } from './proto.js';\n\n/**\n * Symbol for Factory instances.\n * @type {Symbolic}\n */\nconst FACTORY_SYM = Symbolic('fsymbol');\n\n/**\n * Symbol for Factory context.\n * @type {Symbolic}\n */\nexport const CONTEXT_SYM = Symbolic('context');\n\n/**\n * Symbol for Factory configuration.\n * @type {Symbolic}\n */\nexport const CONFIG_SYM = Symbolic('config');\n\n/**\n * Symbol for Factory listeners.\n * @type {Symbolic}\n */\nexport const LISTENERS_SYM = Symbolic('listeners');\n\nlet context;\n\nconst FACTORY_SYMBOLS = {};\n\n/**\n * Base Factory mixin.\n * @mixin FactoryMixin\n *\n * @param {Function} SuperClass The class to mix.\n * @return {Function} A base Factory constructor.\n */\nexport const FactoryMixin = (SuperClass) =>\n    class BaseFactory extends SuperClass {\n        /**\n         * A symbolic defintion for the Factory constructor.\n         * @type {Symbolic}\n         */\n        static get SYM() {\n            if (!hasOwnProperty(this, FACTORY_SYM)) {\n                const sym = Symbolic(this.name);\n                FACTORY_SYMBOLS[sym] = this;\n                this[FACTORY_SYM] = sym;\n            }\n            return this[FACTORY_SYM];\n        }\n\n        constructor(...args) {\n            super(...args);\n            this.initialize(...args);\n        }\n\n        /**\n         * @param {...*} [args] Arguments for super initialize.\n         */\n        initialize(...args) {\n            if (!this[CONTEXT_SYM]) {\n                this[CONTEXT_SYM] = context || this;\n            }\n            return has(SuperClass, 'initialize') && super.initialize(...args);\n        }\n\n        /**\n         * Init a new Factory with the same context.\n         *\n         * @param {Function} Factory The Factory constructor.\n         * @param {...*} args A list of arguments for the constructor.\n         * @return {Object} The new instance.\n         */\n        init(Factory, ...args) {\n            context = this[CONTEXT_SYM];\n            const res = new Factory(...args);\n            context = null;\n            return res;\n        }\n\n        /**\n         * Clear the context.\n         */\n        destroy() {\n            delete this[CONTEXT_SYM];\n            return has(SuperClass, 'destroy') && super.destroy();\n        }\n    };\n\n/**\n * Events emitter mixin.\n * @mixin EmitterMixin\n *\n * @param {Function} SuperClass The class to mix.\n * @return {Function} A Emitter constructor.\n */\nexport const EmitterMixin = (SuperClass) =>\n    class Emitter extends mix(SuperClass).with(FactoryMixin) {\n        /**\n         * @param {...*} [args] Arguments for the constructor.\n         */\n        initialize(...args) {\n            super.initialize(...args);\n            if (!this[LISTENERS_SYM]) {\n                this[LISTENERS_SYM] = [];\n            }\n        }\n\n        /**\n         * Add an event listener.\n         *\n         * @param {string} name The event name.\n         * @param {Function} callback The callback to exec for the event.\n         * @return {Function} A listener destroyer.\n         */\n        on(name, callback) {\n            return on(this, name, callback);\n        }\n\n        /**\n         * Remove an event(s) listener(s).\n         *\n         * @param {string} [name] The event name.\n         * @param {Function} [callback] The optional callback to remove.\n         */\n        off(name, callback) {\n            return off(this, name, callback);\n        }\n\n        /**\n         * Dispatch an event.\n         *\n         * @param {string} name The event name.\n         * @param {...*} args A list of arguments to pass to listeners.\n         * @return {Promise} It resolves when all listeners have been triggered.\n         */\n        trigger(name, ...args) {\n            return trigger(this, name, ...args);\n        }\n\n        /**\n         * Listen events from another object.\n         *\n         * @param {Object} obj The object to listen.\n         * @param {string} name The event name.\n         * @param {Function} callback The callback to exec for the event.\n         * @return {Function} A listener destroyer.\n         */\n        listen(obj, name, callback) {\n            const destroyer = on(obj, name, callback);\n            this[LISTENERS_SYM].push(destroyer);\n            return destroyer;\n        }\n\n        /**\n         * Unlisten event(s) from another object(s).\n         *\n         * @param {Object} [obj] The object to unlisten.\n         * @param {string} [name] The event name.\n         * @param {Function} [callback] The callback to exec for the event.\n         * @return {Function} A listener destroyer.\n         */\n        unlisten(obj, name, callback) {\n            if (obj) {\n                off(obj, name, callback);\n            } else {\n                this[LISTENERS_SYM].forEach((offListener) => offListener());\n                this[LISTENERS_SYM] = [];\n            }\n        }\n\n        /**\n         * Clear all listeners.\n         */\n        destroy() {\n            this.off();\n            this.unlisten();\n            return super.destroy();\n        }\n    };\n\n/**\n * Configurable mixin.\n * @mixin ConfigurableMixin\n *\n * @param {Function} SuperClass The class to mix.\n * @return {Function} A Configurable constructor.\n */\nexport const ConfigurableMixin = (SuperClass) =>\n    class Configurable extends mix(SuperClass).with(FactoryMixin) {\n        /**\n         * @param {Object} [config] The instance configuration object.\n         * @param {...*} [args] Other arguments for the super constructor.\n         */\n        initialize(config, ...args) {\n            super.initialize(config, ...args);\n            if (!this[CONFIG_SYM]) {\n                this[CONFIG_SYM] = clone(this.defaultConfig || {});\n                if (config) {\n                    this.config(config);\n                }\n            }\n        }\n\n        /**\n         * Default config object.\n         */\n        get defaultConfig() {\n            return {};\n        }\n\n        /**\n         * Update instance configuration.\n         *\n         * @param {Object|string} config The configuration to update (or the path of the configuration property).\n         * @param {*} [value] The value to update for the given config name.\n         * @return {Object} Final configuration of the instance.\n         */\n        config(config, ...args) {\n            let current = this[CONFIG_SYM];\n            if (args.length === 0 && isString(config)) {\n                return keypath.get(current, config);\n            }\n            const value = args[0];\n            if (isString(config)) {\n                const oldValue = keypath.get(current, config);\n                if (oldValue !== value) {\n                    keypath.set(current, config, value);\n                    this.trigger('config:changed', config, oldValue, value);\n                }\n            }\n            if (isObject(config)) {\n                current = merge(current, config);\n            }\n            this[CONFIG_SYM] = current;\n            return current;\n        }\n\n        /**\n         * Clear the configuration.\n         */\n        destroy() {\n            delete this[CONFIG_SYM];\n            return super.destroy();\n        }\n    };\n\n/**\n * Mixin for other multiple injections.\n * @mixin InjectableMixin\n *\n * @param {Function} SuperClass The class to mix.\n * @return {Function} A Factory constructor.\n */\nexport const InjectableMixin = (SuperClass) =>\n    class Factory extends mix(SuperClass).with(FactoryMixin) {\n        /**\n         * @param {...*} [args] Arguments for the constructor.\n         */\n        initialize(...args) {\n            super.initialize(...args);\n            const ctx = this[CONTEXT_SYM];\n            this.inject.forEach((Injector) => {\n                if (Symbolic.isSymbolic(Injector)) {\n                    Injector = FACTORY_SYMBOLS[Injector];\n                }\n                if (!this[Injector.SYM]) {\n                    if (ctx) {\n                        this[Injector.SYM] = ctx[Injector.SYM] = ctx[Injector.SYM] || this.init(Injector);\n                    } else {\n                        this[Injector.SYM] = this.init(Injector);\n                    }\n                }\n            });\n        }\n\n        /**\n         * A default list of injections.\n         */\n        get inject() {\n            return [];\n        }\n\n        /**\n         * Clear injected methods.\n         */\n        destroy() {\n            this.inject.forEach((Injector) => {\n                const SYM = (Symbolic.isSymbolic(Injector)) ? Injector : Injector.SYM;\n                delete this[SYM];\n            });\n            return super.destroy();\n        }\n    };\n\nexport class BaseFactory extends mix().with(FactoryMixin) { }\n\nexport class Emitter extends mix().with(EmitterMixin) { }\n\nexport class Configurable extends mix().with(ConfigurableMixin) { }\n\nexport class Factory extends mix().with(EmitterMixin, ConfigurableMixin, InjectableMixin) { }\n", "import hasOwnProperty from './has.js';\n\n/**\n * @module keypath\n */\n\nimport {\n    isNumber,\n    isString,\n    isBoolean,\n    isObject,\n    isArray,\n    isFalsy,\n} from './types.js';\n\n/**\n * Assert scope object is a valid object.\n * @private\n *\n * @param {*} obj The object to check\n * @return {boolean} The object is valid or not\n */\nfunction assertObject(obj) {\n    return !isFalsy(obj) && typeof obj === 'object';\n}\n\n/**\n * Assert scope object and path are valid\n * @private\n *\n * @param {*} obj The object to check\n * @param {*} path The property path\n * @return {void}\n * @throws {Error} throw error when object scope is invalid undefined\n * @throws {Error} throw error when paths is invalid or undefined\n */\nfunction assertArgs(obj, path) {\n    if (!assertObject(obj)) {\n        throw new Error('invalid scope');\n    }\n    if (isFalsy(path) || (isArray(path) && path.length === 0)) {\n        throw new Error('invalid path');\n    }\n}\n\n/**\n * Normalize path argument in an array of paths\n * @private\n *\n * @param {Array|string|number} path The argument to normalize\n * @return {Array} An array of paths\n */\nfunction pathToArray(path) {\n    if (isString(path)) {\n        return path.split('.');\n    }\n    if (isNumber(path)) {\n        return [`${path}`];\n    }\n    if (isArray(path)) {\n        return path.slice(0);\n    }\n    return path;\n}\n\n/**\n * Get a deep property of an object using paths\n * @function get\n * @memberof keypath\n *\n * @param {Object} obj The object scope\n * @param {String|Array} path The path of the property to retrieve\n * @param {*} defaultValue The default value returned if path was not found. Default is undefined.\n * @return {*} The property value\n * @throws {Error} throw error when object scope is undefined\n * @throws {Error} throw error when paths is invalid or undefined\n */\nexport function get(obj, path, defaultValue) {\n    assertArgs(obj, path);\n    if (!has(obj, path)) {\n        return defaultValue;\n    }\n    let value = obj;\n    path = pathToArray(path);\n    path.forEach(prop => {\n        value = value[prop];\n    });\n    return value;\n}\n\n/**\n * Set a deep property of an object using paths\n * @memberof keypath\n *\n * @param {Object} obj The object scope\n * @param {String|Array} path The path of the property to set\n * @param {*} value The value to set\n * @param {boolean} [ensure=true] Create path if does not exists\n * @return {*} The property value\n * @throws {Error} throw error when object scope is invalid undefined\n * @throws {Error} throw error when paths is invalid or undefined\n */\nexport function set(obj, path, value, ensure = true) {\n    assertArgs(obj, path);\n    path = pathToArray(path);\n    if (path.length === 1) {\n        if (isArray(obj) && path[0] === '') {\n            obj.push(value);\n        } else {\n            obj[path[0]] = value;\n        }\n        return value;\n    }\n    const current = path.shift();\n    let currentObj;\n    if (!hasOwnProperty(obj, current)) {\n        if (ensure) {\n            const next = path[0];\n            if (isNaN(next) && next !== '') {\n                currentObj = obj[current] = {};\n            } else {\n                currentObj = obj[current] = [];\n            }\n        }\n    } else {\n        currentObj = obj[current];\n    }\n    return set(currentObj, path, value, ensure);\n}\n\n/**\n * Check deep object property existence using paths\n * @memberof keypath\n *\n * @param {Object} obj The object scope\n * @param {String|Array} path The path of the property to retrieve\n * @return {boolean} The property exists or not\n * @throws {Error} throw error when object scope is invalid undefined\n * @throws {Error} throw error when paths is invalid or undefined\n */\nexport function has(obj, path) {\n    if (!assertObject(obj)) {\n        return false;\n    }\n    assertArgs(obj, path);\n    path = pathToArray(path);\n    let current = path.shift();\n    if (isArray(obj) && !isNaN(current)) {\n        current = parseInt(current);\n        if (obj.length > current) {\n            if (path.length === 0) {\n                return true;\n            }\n            return has(obj[current], path);\n        }\n    }\n    if (current in obj || hasOwnProperty(obj, current)) {\n        if (path.length === 0) {\n            return true;\n        }\n        return has(obj[current], path);\n    }\n    return false;\n}\n\n/**\n * Ensure the existance of a value for the given path.\n * If the value already exists, do nothing.\n * @function ensure\n * @memberof keypath\n *\n * @param {Object} obj The object scope\n * @param {String|Array} path The path of the property to retrieve\n * @param {*} value The default value to set\n * @return {*} The actual value for the given property\n * @throws {Error} throw error when object scope is invalid undefined\n * @throws {Error} throw error when paths is invalid or undefined\n */\nexport function ensure(obj, path, value) {\n    const val = get(obj, path);\n    if (!val) {\n        set(obj, path, value);\n    }\n    return val;\n}\n\n/**\n * Push or insert a value in array.\n * @memberof keypath\n *\n * @param {Object} obj The object scope\n * @param {String|Array} path The path of the property to retrieve\n * @param {*} value The value to push\n * @param {number} [index] The index to replace (empty, push at the end)\n * @return {Array} The modified array\n * @throws {Error} throw error when object scope is invalid undefined\n * @throws {Error} throw error when paths is invalid or undefined\n */\nexport function insert(obj, path, value, index) {\n    assertArgs(obj, path);\n    path = pathToArray(path);\n    let arr = [];\n    arr = ensure(obj, path, arr) || arr;\n    if (isArray(arr)) {\n        if (!isFalsy(index)) {\n            arr.splice(index, 0, value);\n        } else {\n            arr.push(value);\n        }\n    }\n    return arr;\n}\n\n/**\n * Reset the value at the given path.\n * * Object \u2192 remove all keys from the object\n * * Array \u2192 remove all values from the array\n * * String \u2192 reset to empty string\n * * Number \u2192 reset to 0\n * * any \u2192 reset to null\n * @memberof keypath\n *\n * @param {Object} obj The object scope\n * @param {String|Array} path The path of the property to retrieve\n * @return {*} The modified object\n * @throws {Error} throw error when object scope is invalid undefined\n * @throws {Error} throw error when paths is invalid or undefined\n */\nexport function empty(obj, path) {\n    assertArgs(obj, path);\n    path = pathToArray(path);\n    let parent = obj;\n    if (path.length > 1) {\n        parent = get(obj, path.slice(0, -1));\n    }\n    const current = path[path.length - 1];\n    if (parent && hasOwnProperty(parent, current)) {\n        const arr = parent[current];\n        if (isArray(arr)) {\n            arr.splice(0, arr.length);\n        } else if (isObject(arr)) {\n            for (const k in arr) {\n                delete arr[k];\n            }\n        } else if (isString(arr)) {\n            parent[current] = '';\n        } else if (isNumber(arr)) {\n            parent[current] = 0;\n        } else if (isBoolean(arr)) {\n            parent[current] = false;\n        } else {\n            parent[current] = null;\n        }\n        return arr;\n    }\n    return null;\n}\n\n/**\n * Remove a key from the parent path.\n * @memberof keypath\n *\n * @param {Object} obj The object scope\n * @param {String|Array} path The path of the property to retrieve\n * @return {*} The parent path object\n * @throws {Error} throw error when object scope is invalid undefined\n * @throws {Error} throw error when paths is invalid or undefined\n */\nexport function del(obj, path) {\n    assertArgs(obj, path);\n    path = pathToArray(path);\n    const pathToDelete = path.pop();\n    let subObj = obj;\n    if (path.length) {\n        subObj = get(obj, path);\n    }\n    if (isObject(subObj)) {\n        delete subObj[pathToDelete];\n    } else if (isArray(subObj) && !isNaN(pathToDelete)) {\n        subObj.splice(pathToDelete, 1);\n    }\n    return subObj;\n}\n", "import Symbolic from './symbolic.js';\nimport has from './has.js';\nimport { isFunction } from './types.js';\n\nconst SYM = Symbolic('listeners');\n\n/**\n * Add a callback for the specified trigger.\n *\n * @param {Object} scope The event scope\n * @param {String} name The event name\n * @param {Function} callback The callback function\n * @return {Function} Destroy created listener with this function\n */\nexport function on(scope, name, callback) {\n    if (!isFunction(callback)) {\n        throw new TypeError('callback is not a function');\n    }\n    scope[SYM] = scope[SYM] || {};\n    const callbacks = scope[SYM];\n    const evtCallbacks = callbacks[name] = callbacks[name] || [];\n    evtCallbacks.push(callback);\n    return off.bind(null, scope, name, callback);\n}\n\n/**\n * Remove one or multiple listeners.\n *\n * @param {Object} scope The event scope\n * @param {String} [name] Optional event name to reset\n * @param {Function} [callback] Callback to remove (empty, removes all listeners).\n */\nexport function off(scope, name, callback) {\n    if (callback) {\n        const callbacks = scope[SYM];\n        if (callbacks) {\n            const evtCallbacks = callbacks[name] = callbacks[name] || [];\n            const io = evtCallbacks.indexOf(callback);\n            if (io !== -1) {\n                evtCallbacks.splice(io, 1);\n            }\n        }\n    } else if (name) {\n        const callbacks = scope[SYM];\n        if (callbacks) {\n            delete callbacks[name];\n        }\n    } else {\n        scope[SYM] = {};\n    }\n}\n\n/**\n * Trigger a callback.\n *\n * @param {Object} scope The event scope\n * @param {String} name Event name\n * @param {...*} args Arguments to pass to callbacks\n * @return {Promise} The final Promise of the callbacks chain\n */\nexport function trigger(scope, name, ...args) {\n    const callbacksList = (has(scope, SYM) && has(scope[SYM], name) && scope[SYM][name]) || [];\n    const finalResults = callbacksList\n        .slice(0)\n        .reduce((results, callback) => {\n            if (callbacksList.indexOf(callback) === -1) {\n                // the callback has been removed from the callback list.\n                return results;\n            }\n            const lastResult = results[results.length - 1];\n            let result;\n            if (lastResult instanceof Promise) {\n                // wait for the previous result.\n                result = lastResult.then(() => callback.call(scope, ...args));\n            } else {\n                result = callback.call(scope, ...args);\n            }\n            results.push(result);\n            return results;\n        }, []);\n\n    return Promise.all(finalResults);\n}\n", "import { Emitter } from './factory.js';\nimport { isArray, isObject } from './types.js';\nimport { get, set, extend, reconstruct } from './proto.js';\nimport Symbolic from './symbolic.js';\n/**\n * @typedef ChangeSet\n * @property {String} property The path to the changed property.\n * @property {*} oldValue The old value for the property.\n * @property {*} newValue The new value for the property.\n * @property {Array} added A list of added items to an array.\n * @property {Array} remove A list of remove items from an array.\n */\n/**\n * Observable Symbol.\n * @type {Symbolic}\n * @private\n */\nconst OBSERVABLE_SYM = Symbolic('observable');\n/**\n * Array prototype shortcut.\n * @type {Object}\n * @private\n */\nconst ARRAY_PROTO = Array.prototype;\n/**\n * Object.prototype.hasOwnProperty shortcut.\n * @type {Function}\n * @private\n */\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n/**\n * Micro Proxy polyfill.\n * @private\n */\nconst ProxyHelper = typeof Proxy !== 'undefined' ? Proxy : class {\n    constructor(data, handler) {\n        const res = reconstruct(get(data));\n        Object.keys(data)\n            .filter((key) => Object.getOwnPropertyDescriptor(data, key).configurable)\n            .forEach((key) => {\n                this.define(res, data, key, handler);\n            });\n        if (isArray(data)) {\n            let lastLength = data.length;\n            res.on('change', () => {\n                if (data.length !== lastLength) {\n                    Object.keys(data).forEach((key) => {\n                        if (key !== OBSERVABLE_SYM) {\n                            this.define(res, data, key, handler);\n                        }\n                    });\n                    lastLength = data.length;\n                }\n            });\n        }\n        res[OBSERVABLE_SYM] = data[OBSERVABLE_SYM];\n        return res;\n    }\n    define(res, data, property, handler) {\n        const desc = {\n            configurable: true,\n            enumerable: ('enumerable' in handler) ? handler.enumerable : !Symbolic.isSymbolic(property),\n        };\n        if (handler.get) {\n            desc.get = () => handler.get(data, property);\n        }\n        if (handler.set) {\n            desc.set = (val) => handler.set(data, property, val);\n        }\n        Object.defineProperty(res, property, desc);\n    }\n};\n/**\n * Trigger object changes.\n * @private\n *\n * @param {Object|Array} scope The updated object.\n * @param {ChangeSet} changeset The changes descriptor.\n */\nfunction triggerChanges(scope, changeset) {\n    return scope[OBSERVABLE_SYM].trigger('change', changeset);\n}\n/**\n * Wrap Array prototype methods for changes triggering.\n * @type {Object}\n * @private\n */\nconst ARRAY_PROTO_WRAP = {\n    push(...items) {\n        const length = this.length;\n        items = items.map((item, index) =>\n            subobserve(this, length + index, item)\n        );\n        const res = ARRAY_PROTO.push.call(this, ...items);\n        triggerChanges(this, {\n            property: length,\n            added: items,\n            removed: [],\n        });\n        return res;\n    },\n    unshift(item) {\n        const res = ARRAY_PROTO.unshift.call(this, item);\n        subobserve(this, 0, item);\n        triggerChanges(this, {\n            property: 0,\n            added: [item],\n            removed: [],\n        });\n        return res;\n    },\n    pop() {\n        const res = ARRAY_PROTO.pop.call(this);\n        triggerChanges(this, {\n            property: this.length,\n            added: [],\n            removed: [res],\n        });\n        return res;\n    },\n    shift() {\n        const res = ARRAY_PROTO.shift.call(this);\n        triggerChanges(this, {\n            property: 0,\n            added: [],\n            removed: [res],\n        });\n        return res;\n    },\n    splice(index, count, ...items) {\n        items = items.map((item, index) =>\n            subobserve(this, this.length + index, item)\n        );\n        const res = ARRAY_PROTO.splice.call(this, index, count, ...items);\n        triggerChanges(this, {\n            property: index,\n            added: items,\n            removed: [res],\n        });\n        return res;\n    },\n};\n/**\n * Subobserve objects.\n * @private\n *\n * @param {Object|Array} target The root object.\n * @param {String} name The root object property name\n * @param {Object|Array} value The sub object to observe.\n * @return {Observable} The Observable instance for the sub object.\n */\nfunction subobserve(target, name, value) {\n    if (isObject(value) || isArray(value)) {\n        value = new Observable(value);\n        value.on('change', (changeset) => {\n            name = isArray(target) ? target.indexOf(value) : name;\n            const changes = {\n                property: `${name}.${changeset.property}`,\n            };\n            if (hasOwnProperty.call(changeset, 'value')) {\n                changes.oldValue = changeset.oldValue;\n                changes.value = changeset.value;\n            } else if (hasOwnProperty.call(changeset, 'added')) {\n                changes.added = changeset.added;\n                changes.removed = changeset.removed;\n            }\n            triggerChanges(target, changes);\n        });\n    }\n    return value;\n}\n/**\n * ES6 Proxy handler.\n * @type {Object}\n * @private\n */\nconst handler = {\n    getPrototypeOf(target) {\n        if (isArray(target)) {\n            return target.constructor.prototype;\n        }\n        return Reflect.getPrototypeOf(target);\n    },\n    get: (target, name) => target[name],\n    set: (target, name, value) => {\n        if (Symbolic.isSymbolic(name)) {\n            return target[name] = value;\n        }\n        const oldValue = target[name];\n        if (target[name] !== value) {\n            value = subobserve(target, name, value);\n            target[name] = value;\n            triggerChanges(target, {\n                property: name,\n                oldValue,\n                value,\n            });\n        }\n        return true;\n    },\n};\n/**\n * Create an Observable object for a set of data or an array.\n *\n * @param {Object|Array} data The object to observe.\n * @return {Proxy} The observed object proxy.\n */\nexport default class Observable {\n    constructor(data) {\n        if (typeof data !== 'object') {\n            throw new Error('Cannot observe this value.');\n        }\n        const emitter = data[OBSERVABLE_SYM] || new Emitter();\n\n        if (emitter.proxy) {\n            return emitter.proxy;\n        }\n        const proto = {\n            on: { value: emitter.on.bind(emitter) },\n            off: { value: emitter.off.bind(emitter) },\n            trigger: { value: emitter.trigger.bind(emitter) },\n        };\n        if (isArray(data)) {\n            proto.push = { get: () => ARRAY_PROTO_WRAP.push.bind(data) };\n            proto.unshift = { get: () => ARRAY_PROTO_WRAP.unshift.bind(data) };\n            proto.pop = { get: () => ARRAY_PROTO_WRAP.pop.bind(data) };\n            proto.shift = { get: () => ARRAY_PROTO_WRAP.shift.bind(data) };\n            proto.splice = { get: () => ARRAY_PROTO_WRAP.splice.bind(data) };\n        }\n        data[OBSERVABLE_SYM] = emitter;\n        set(data, extend(get(data), proto));\n        emitter.proxy = new ProxyHelper(data, handler);\n        Object.keys(data).forEach((key) => {\n            if (key !== OBSERVABLE_SYM) {\n                data[key] = subobserve(data, key, data[key]);\n            }\n        });\n        return emitter.proxy;\n    }\n    /**\n     * Re-observe an array or an object after adding a property.\n     *\n     * You should invoke this static method only after adding a new property\n     * to an object, and only if you wish to support browsers that do not have\n     * native Proxy object. This is required because it is impossible to\n     * intercept new properties added to an existing object from the polyfill.\n     *\n     * ## Example\n     *\n     * ```js\n     * const myObservable = new Observable({ foo: 'foo' });\n     *\n     * // This is not enough to trigger changes in older browsers!\n     * myObservable.bar = 'bar';\n     *\n     * // So, you should invoke this immediately after:\n     * Observable.reobserve(myObservable);\n     * ```\n     *\n     * @param {Object|Array} data Data to be re-observed.\n     * @return {void}\n     */\n    static reobserve(data) {\n        if (typeof Proxy !== 'undefined') {\n            // Native proxy support. We're good.\n            return;\n        }\n        // Ensure `data` is an observable.\n        new Observable(data);\n        Object.keys(data).forEach((key) => {\n            const descriptor = Object.getOwnPropertyDescriptor(data, key);\n            if (key !== OBSERVABLE_SYM && descriptor && descriptor.configurable && ('value' in descriptor)) {\n                // Key has been added and is not yet observed. Big Brother is on its way.\n                data[key] = subobserve(data, key, data[key]);\n                triggerChanges(data, {\n                    property: key,\n                    oldValue: undefined,\n                    value: data[key],\n                });\n            }\n        });\n    }\n}\n", "/**\n * @module Url\n */\n\nimport * as keypath from './keypath.js';\nimport Symbolic from './symbolic.js';\nimport { isArray, isIterable } from './types.js';\nimport { entries as objectEntries } from './_helpers.js';\n\nconst REF_SYM = Symbolic('ref');\nconst URL_REGEX = /((?:^(?:[a-z]+:))|^)?(?:\\/\\/)?([^?/$]*)([^?]*)?(\\?.*)?/i;\nconst PORT_REGEX = /:\\d*$/;\n\n/**\n * Parse and split an url in its components.\n *\n * @param {string} url The url to parse.\n * @return {Object} The url properties.\n */\nexport function parse(url = '') {\n    const hashSplit = url.split('#');\n    const hash = hashSplit.length > 1 ? hashSplit.pop() : undefined;\n    url = hashSplit.join('#');\n    const match = url.match(URL_REGEX);\n    const res = {\n        host: undefined,\n        hostname: undefined,\n        port: undefined,\n        username: undefined,\n        password: undefined,\n        hash,\n    };\n    if (match) {\n        res.protocol = match[1];\n        if (match[2]) {\n            let host = match[2];\n            res.host = host;\n            const port = host.match(PORT_REGEX);\n            if (port) {\n                res.port = port[0].substring(1);\n                host = host.replace(port[0], '');\n            }\n            const authSplit = host.split('@');\n            res.hostname = authSplit.pop();\n            const authChunk = authSplit.join('@').split(':');\n            res.username = authChunk.shift();\n            res.password = authChunk.join(':');\n        }\n        res.pathname = match[3];\n        res.search = match[4];\n    }\n    if (!match ||\n        (res.port && !res.hostname) ||\n        (res.protocol && res.protocol !== 'file:' && !res.hostname) ||\n        (res.search && !res.hostname && !res.pathname) ||\n        (res.password && !res.username)\n    ) {\n        throw new SyntaxError('invalid url');\n    }\n    if (res.host && res.pathname === '/') {\n        res.pathname = '';\n    }\n    if (res.hostname) {\n        let origin = res.protocol ? `${res.protocol}//` : '';\n        origin += res.hostname;\n        origin += res.port ? `:${res.port}` : '';\n        res.origin = origin;\n    }\n    return res;\n}\n\n/**\n * Serialize a key/value pair matching differente operators.\n *\n * @param {string} key The pair key.\n * @param {string} val The pair value.\n * @return {string} A serialized string of key/value pair.\n */\nfunction chunk(key, val) {\n    if (val) {\n        return `${encodeURIComponent(key)}=${encodeURIComponent(val)}`;\n    }\n    return `${encodeURIComponent(key)}`;\n}\n\n/**\n * Serialize an object in FormData format.\n *\n * @param {Object} searchParams The object to convert.\n * @param {string} prefix The prefix to use in case of recursion.\n * @param {Function} [chunkFn] The callback function to use for chunking a key/value pair.\n * @return {string} An object to serialize.\n */\nexport function serialize(searchParams, prefix, chunkFn = chunk) {\n    const str = [];\n    const entries = isIterable(searchParams) && !isArray(searchParams) ? searchParams : objectEntries(searchParams);\n\n    for (const [propertyKey, value] of entries) {\n        if (value == null) {\n            continue;\n        }\n\n        const key = prefix ? `${prefix}[${propertyKey}]` : propertyKey;\n        let serialized = value;\n        if (value instanceof Date) {\n            serialized = value.toISOString();\n        }\n\n        if (typeof serialized === 'object') {\n            serialized = serialize(serialized, key);\n        } else if (serialized != null) {\n            serialized = chunkFn(key, `${serialized}`);\n        }\n\n        if (serialized != null) {\n            str.push(serialized);\n        }\n    }\n\n    if (!str.length && prefix != null) {\n        str.push(chunkFn(prefix));\n    }\n\n    return str.join('&');\n}\n\n/**\n * Unserialize a string in FormData format to an object.\n *\n * @param {string} str A search string to unserialize.\n * @return {object} The unserialized object.\n */\nexport function unserialize(str) {\n    str = decodeURI(str);\n    const chunks = str.split('&');\n    const res = {};\n\n    for (let i = 0, len = chunks.length; i < len; i++) {\n        const chunk = chunks[i].split('=');\n        if (chunk[0] && chunk[1]) {\n            const key = chunk[0].replace(/\\[(.*?)\\]/g, '.$1');\n            const val = decodeURIComponent(chunk[1]);\n            keypath.set(res, key, val);\n        }\n    }\n\n    return res;\n}\n\n/**\n * Join url paths.\n *\n * @param {...string} paths A list of paths to join.\n * @return {string} The final join string.\n */\nexport function join(...paths) {\n    return paths\n        .map((path) => (path || '').replace(/^\\/*/, '').replace(/\\/*$/, ''))\n        .filter((path) => !!path)\n        .join('/');\n}\n\n/**\n * Resolve relative url path.\n *\n * @param {string} base The base path.\n * @param {string} relative The relative path.\n * @return {string} The rsolved path.\n */\nexport function resolve(base, relative) {\n    if (relative[0] === '/') {\n        const baseInfo = parse(base);\n        if (!baseInfo.origin) {\n            throw new Error('base url is not an absolute url');\n        }\n        base = `${baseInfo.origin}/`;\n    }\n    const stack = base.split('/');\n    const parts = relative.split('/').filter((part) => part !== '');\n    if (stack.length > 1) {\n        stack.pop();\n    }\n    for (let i = 0; i < parts.length; i++) {\n        if (parts[i] === '.') {\n            continue;\n        } else if (parts[i] === '..') {\n            stack.pop();\n        } else {\n            stack.push(parts[i]);\n        }\n    }\n    return stack.join('/');\n}\n\n/**\n * Check if an url is absolute.\n *\n * @param {string} url The url to check.\n * @return {boolean}\n */\nexport function isAbsoluteUrl(url) {\n    return !!parse(url).protocol;\n}\n\n/**\n * Check if an url is a data url.\n *\n * @param {string} url The url to check.\n * @return {boolean}\n */\nexport function isDataUrl(url) {\n    return parse(url).protocol === 'data:';\n}\n\n/**\n * Check if an url points to a local file.\n *\n * @param {string} url The url to check.\n * @return {boolean}\n */\nexport function isLocalUrl(url) {\n    return parse(url).protocol === 'file:';\n}\n\n/**\n * Update query string params to an url\n *\n * @param {Url} url The url to update.\n * @param {string} path The query string.\n * @return {string}\n */\nfunction updateSearchPath(url, path) {\n    const href = url.href.split('?')[0];\n    if (!path) {\n        return url.href = href;\n    }\n    return url.href = `${href}?${path}`;\n}\n\n/**\n * Convert search params entries to a query string.\n *\n * @param {Array} entries Search params entries.\n * @return {string} The query string.\n */\nfunction entriesToString(entries) {\n    const unserialized = {};\n    entries.forEach((entry) => {\n        unserialized[entry[0]] = entry[1];\n    });\n    return serialize(unserialized);\n}\n\n/**\n * Search params interface for Url.\n */\nexport class SearchParams {\n    /**\n     * Create search params instance.\n     * @param {Url} ref The referenced Url instance.\n     */\n    constructor(ref) {\n        this[REF_SYM] = ref;\n    }\n\n    /**\n     * The referenced Url.\n     * @type {Url}\n     */\n    get url() {\n        return this[REF_SYM];\n    }\n\n    /**\n     * List all entry keys.\n     *\n     * @return {Array} Entry keys list.\n     */\n    keys() {\n        return this.entries()\n            .map((entry) => entry[0]);\n    }\n\n    /**\n     * List all entry values.\n     *\n     * @return {Array} Entry values list.\n     */\n    values() {\n        return this.entries()\n            .map((entry) => entry[1]);\n    }\n\n    /**\n     * List all entries.\n     *\n     * @return {[string, any]} Entries list in format [[key, value], [...]].\n     */\n    entries() {\n        if (!this.url.search) {\n            return [];\n        }\n        const search = this.url.search.substring(1);\n        const unserialized = unserialize(search);\n        return Object.keys(unserialized)\n            .map((key) => [key, unserialized[key]]);\n    }\n\n    /**\n     * Retrieve an entry.\n     *\n     * @param {string} name The entity name to get.\n     * @return {*} The entity value.\n     */\n    get(name) {\n        const entries = this.entries();\n        for (let i = 0, len = entries.length; i < len; i++) {\n            if (entries[i][0] === name) {\n                return entries[i][1];\n            }\n        }\n    }\n\n    /**\n     * Check if entity is defined.\n     *\n     * @param {string} name The entity name to check.\n     * @return {Boolean}\n     */\n    has(name) {\n        return !!this.get(name);\n    }\n\n    /**\n     * Set an entry value.\n     *\n     * @param {string} name The entity name to set.\n     * @param {*} value The entity value to set\n     */\n    set(name, value) {\n        this.delete(name);\n        const entries = this.entries();\n        entries.push([name, value]);\n        updateSearchPath(\n            this.url,\n            entriesToString(entries)\n        );\n    }\n\n    /**\n     * Remove an entity from the search params.\n     *\n     * @param {string} name The entity name to remove.\n     */\n    delete(name) {\n        updateSearchPath(\n            this.url,\n            entriesToString(\n                this.entries().filter((entry) => entry[0] !== name)\n            )\n        );\n    }\n\n    /**\n     * Sort entities by keys names.\n     */\n    sort() {\n        const entries = this.entries();\n        entries.sort((entry1, entry2) => {\n            const key1 = entry1[0];\n            const key2 = entry2[0];\n            if (key1 < key2) {\n                return -1;\n            } else if (key1 > key2) {\n                return 1;\n            }\n            return 0;\n        });\n        updateSearchPath(this.url, entriesToString(entries));\n    }\n\n    toString() {\n        return this.url.search;\n    }\n}\n\n/**\n * Url helper class.\n */\nexport class Url {\n    /**\n     * Create a Url instance.\n     * @param {string} path The url to handle.\n     * @param {string} [baseUrl] The optional base url.\n     */\n    constructor(path, baseUrl) {\n        /**\n         * The url's protocol (if defined).\n         * @type {string|undefined}\n         */\n        this.protocol = undefined;\n        /**\n         * The username used (if defined).\n         * @type {string|undefined}\n         */\n        this.username = undefined;\n        /**\n         * The password used (if defined).\n         * @type {string|undefined}\n         */\n        this.password = undefined;\n        /**\n         * The url's host.\n         * @type {string|undefined}\n         */\n        this.host = undefined;\n        /**\n         * The url's hostname.\n         * @type {string|undefined}\n         */\n        this.hostname = undefined;\n        /**\n         * The url's pathname.\n         * @type {string|undefined}\n         */\n        this.pathname = undefined;\n        /**\n         * The url's port (if defined).\n         * @type {string|undefined}\n         */\n        this.port = undefined;\n        /**\n         * The url's query params.\n         * @type {string|undefined}\n         */\n        this.search = undefined;\n        /** The url's hash.\n         * @type {string|undefined}\n         */\n        this.hash = undefined;\n        /**\n         * The full url string.\n         * @type {string}\n        */\n        this.href = baseUrl ? resolve(baseUrl, path) : path;\n        /**\n         * The url query string interface.\n         * @type {SearchParams}\n         */\n        this.searchParams = new SearchParams(this);\n    }\n\n    get href() {\n        return this[REF_SYM];\n    }\n\n    set href(href) {\n        const info = parse(href);\n        this[REF_SYM] = href;\n        for (const k in info) {\n            this[k] = info[k];\n        }\n    }\n\n    /**\n     * Join current Url with paths.\n     *\n     * @param {...string} paths A list of paths to join.\n     * @return {Url} A new url instance.\n     */\n    join(...paths) {\n        return new Url(join(this.href, ...paths));\n    }\n\n    /**\n     * Resolve a path relative to the current Url.\n     *\n     * @param {string} path The relative path.\n     * @return {Url} A new url instance.\n     */\n    resolve(path) {\n        return new Url(resolve(this.href, path));\n    }\n\n    /**\n     * Check if current Url is absolute.\n     *\n     * @return {Boolean}\n     */\n    isAbsoluteUrl() {\n        return isAbsoluteUrl(this.href);\n    }\n\n    /**\n     * Check if current Url is a data url.\n     *\n     * @return {Boolean}\n     */\n    isDataUrl() {\n        return isDataUrl(this.href);\n    }\n\n    /**\n     * Check if current Url points to local file.\n     *\n     * @return {Boolean}\n     */\n    isLocalUrl() {\n        return isLocalUrl(this.href);\n    }\n\n    toString() {\n        return this.href;\n    }\n}\n", "import { flat } from './_helpers.js';\n\n/**\n * Execute a bunch of promises in parallel limiting the number of parallel pending promises.\n *\n * @param {number} workers Number of parallel workers.\n * @param {Iterable<() => Promise<T>>} promiseFactories Iterable of promise factories.\n * @returns {Promise<T[]>}\n * @template T\n */\nexport function pool(workers, promiseFactories) {\n    if (workers < 1) {\n        throw new Error('Number of workers must be positive');\n    }\n\n    const iterator = indexedIterator(promiseFactories);\n    const promises = [];\n    for (let i = 0; i < workers; i++) {\n        promises.push(worker(iterator));\n    }\n\n    return Promise.all(promises)\n        .then((results) => flat.call(results)\n            .sort((a, b) => a.index - b.index)\n            .map(({ result }) => result)\n        );\n}\n\n/**\n * Worker function that dequeues a promise factory and executes it.\n *\n * @param {Iterator<{index: number, value: () => Promise<T>}>} iterator Iterator.\n * @param {{index: number, result: T}[]} results\n * @return {Promise<{index: number, result: T}[]>}\n * @template T\n */\nfunction worker(iterator, results = []) {\n    const next = iterator.next();\n    if (next.done) {\n        return Promise.resolve(results);\n    }\n\n    const { index, value } = next.value;\n\n    return value()\n        .then((result) => {\n            results.push({ index, result });\n\n            return worker(iterator, results);\n        });\n}\n\n/**\n * Iterate over another iterable and keep track of the current index.\n *\n * @param {Iterable<T>} it Original iterable.\n * @returns {Generator<{index: number, value: T}>}\n * @template T\n */\nfunction* indexedIterator(it) {\n    let index = 0;\n    for (const value of it) {\n        yield { index: index++, value };\n    }\n}\n"],
  "mappings": "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",
  "names": ["has", "has", "entries", "get", "has", "set", "get", "has", "set", "ensure", "has", "Factory", "get", "set", "SYM", "handler", "index", "entries", "chunk", "set"]
}
